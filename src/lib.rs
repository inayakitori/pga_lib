// Written by GAmphetamine.js

// Type definition section

#![allow(warnings)]

pub type scalar_t = f32;
/// VECTOR : {e1, e2, e3, e0}
#[derive(Clone, Copy, Debug)]
pub struct vector_t {
    d: [f32; 4],
}

impl vector_t {

    pub fn new(e1: f32, e2: f32, e3: f32, e0: f32) -> Self {
        let d = [e1, e2, e3, e0];
        Self { d }
    }
    pub fn e1(&self) -> f32 { self.d[0] }
    pub fn e2(&self) -> f32 { self.d[1] }
    pub fn e3(&self) -> f32 { self.d[2] }
    pub fn e0(&self) -> f32 { self.d[3] }
}
/// BIVECTOR : {e23, e31, e12, e01, e02, e03}
#[derive(Clone, Copy, Debug)]
pub struct bivector_t {
    d: [f32; 6],
}

impl bivector_t {

    pub fn new(e23: f32, e31: f32, e12: f32, e01: f32, e02: f32, e03: f32) -> Self {
        let d = [e23, e31, e12, e01, e02, e03];
        Self { d }
    }
    pub fn e23(&self) -> f32 { self.d[0] }
    pub fn e31(&self) -> f32 { self.d[1] }
    pub fn e12(&self) -> f32 { self.d[2] }
    pub fn e01(&self) -> f32 { self.d[3] }
    pub fn e02(&self) -> f32 { self.d[4] }
    pub fn e03(&self) -> f32 { self.d[5] }
}
/// TRIVECTOR : {e032, e013, e021, e123}
#[derive(Clone, Copy, Debug)]
pub struct trivector_t {
    d: [f32; 4],
}

impl trivector_t {

    pub fn new(e032: f32, e013: f32, e021: f32, e123: f32) -> Self {
        let d = [e032, e013, e021, e123];
        Self { d }
    }
    pub fn e032(&self) -> f32 { self.d[0] }
    pub fn e013(&self) -> f32 { self.d[1] }
    pub fn e021(&self) -> f32 { self.d[2] }
    pub fn e123(&self) -> f32 { self.d[3] }
}
/// QUADVECTOR : {e0123}
#[derive(Clone, Copy, Debug)]
pub struct quadvector_t {
    d: [f32; 1],
}

impl quadvector_t {

    pub fn new(e0123: f32) -> Self {
        let d = [e0123];
        Self { d }
    }
    pub fn e0123(&self) -> f32 { self.d[0] }
}
/// HORIZON : {e0}
#[derive(Clone, Copy, Debug)]
pub struct horizon_t {
}

impl horizon_t {

    pub fn new() -> Self {
        Self {}
    }
    pub fn e0(&self) -> f32 { 1.0 }
}
/// ORIGIN : {e123}
#[derive(Clone, Copy, Debug)]
pub struct origin_t {
}

impl origin_t {

    pub fn new() -> Self {
        Self {}
    }
    pub fn e123(&self) -> f32 { 1.0 }
}
/// POINT : {e032, e013, e021, e123}
#[derive(Clone, Copy, Debug)]
pub struct point_t {
    d: [f32; 3],
}

impl point_t {

    pub fn new(e032: f32, e013: f32, e021: f32) -> Self {
        let d = [e032, e013, e021];
        Self { d }
    }
    pub fn e032(&self) -> f32 { self.d[0] }
    pub fn e013(&self) -> f32 { self.d[1] }
    pub fn e021(&self) -> f32 { self.d[2] }
    pub fn e123(&self) -> f32 { 1.0 }
}
/// DIRECTION : {e032, e013, e021}
#[derive(Clone, Copy, Debug)]
pub struct direction_t {
    d: [f32; 3],
}

impl direction_t {

    pub fn new(e032: f32, e013: f32, e021: f32) -> Self {
        let d = [e032, e013, e021];
        Self { d }
    }
    pub fn e032(&self) -> f32 { self.d[0] }
    pub fn e013(&self) -> f32 { self.d[1] }
    pub fn e021(&self) -> f32 { self.d[2] }
}
/// EBIVECTOR : {e23, e31, e12}
#[derive(Clone, Copy, Debug)]
pub struct ebivector_t {
    d: [f32; 3],
}

impl ebivector_t {

    pub fn new(e23: f32, e31: f32, e12: f32) -> Self {
        let d = [e23, e31, e12];
        Self { d }
    }
    pub fn e23(&self) -> f32 { self.d[0] }
    pub fn e31(&self) -> f32 { self.d[1] }
    pub fn e12(&self) -> f32 { self.d[2] }
}
/// IBIVECTOR : {e01, e02, e03}
#[derive(Clone, Copy, Debug)]
pub struct ibivector_t {
    d: [f32; 3],
}

impl ibivector_t {

    pub fn new(e01: f32, e02: f32, e03: f32) -> Self {
        let d = [e01, e02, e03];
        Self { d }
    }
    pub fn e01(&self) -> f32 { self.d[0] }
    pub fn e02(&self) -> f32 { self.d[1] }
    pub fn e03(&self) -> f32 { self.d[2] }
}
/// EVECTOR : {e1, e2, e3}
#[derive(Clone, Copy, Debug)]
pub struct evector_t {
    d: [f32; 3],
}

impl evector_t {

    pub fn new(e1: f32, e2: f32, e3: f32) -> Self {
        let d = [e1, e2, e3];
        Self { d }
    }
    pub fn e1(&self) -> f32 { self.d[0] }
    pub fn e2(&self) -> f32 { self.d[1] }
    pub fn e3(&self) -> f32 { self.d[2] }
}
/// DPOINT : {e1, e2, e3, e0}
#[derive(Clone, Copy, Debug)]
pub struct dpoint_t {
    d: [f32; 3],
}

impl dpoint_t {

    pub fn new(e1: f32, e2: f32, e3: f32) -> Self {
        let d = [e1, e2, e3];
        Self { d }
    }
    pub fn e1(&self) -> f32 { self.d[0] }
    pub fn e2(&self) -> f32 { self.d[1] }
    pub fn e3(&self) -> f32 { self.d[2] }
    pub fn e0(&self) -> f32 { 1.0 }
}
/// ROTATION : {1, e23, e31, e12}
#[derive(Clone, Copy, Debug)]
pub struct rotation_t {
    d: [f32; 4],
}

impl rotation_t {

    pub fn new(s: f32, e23: f32, e31: f32, e12: f32) -> Self {
        let d = [s, e23, e31, e12];
        Self { d }
    }
    pub fn s(&self) -> f32 { self.d[0] }
    pub fn e23(&self) -> f32 { self.d[1] }
    pub fn e31(&self) -> f32 { self.d[2] }
    pub fn e12(&self) -> f32 { self.d[3] }
}
/// TRANSLATION : {e01, e02, e03, 1}
#[derive(Clone, Copy, Debug)]
pub struct translation_t {
    d: [f32; 3],
}

impl translation_t {

    pub fn new(e01: f32, e02: f32, e03: f32) -> Self {
        let d = [e01, e02, e03];
        Self { d }
    }
    pub fn e01(&self) -> f32 { self.d[0] }
    pub fn e02(&self) -> f32 { self.d[1] }
    pub fn e03(&self) -> f32 { self.d[2] }
    pub fn s(&self) -> f32 { 1.0 }
}
/// EVEN : {1, e23, e31, e12, e01, e02, e03, e0123}
#[derive(Clone, Copy, Debug)]
pub struct even_t {
    d: [f32; 8],
}

impl even_t {

    pub fn new(s: f32, e23: f32, e31: f32, e12: f32, e01: f32, e02: f32, e03: f32, e0123: f32) -> Self {
        let d = [s, e23, e31, e12, e01, e02, e03, e0123];
        Self { d }
    }
    pub fn s(&self) -> f32 { self.d[0] }
    pub fn e23(&self) -> f32 { self.d[1] }
    pub fn e31(&self) -> f32 { self.d[2] }
    pub fn e12(&self) -> f32 { self.d[3] }
    pub fn e01(&self) -> f32 { self.d[4] }
    pub fn e02(&self) -> f32 { self.d[5] }
    pub fn e03(&self) -> f32 { self.d[6] }
    pub fn e0123(&self) -> f32 { self.d[7] }
}
/// ODD : {e1, e2, e3, e0, e032, e013, e021, e123}
#[derive(Clone, Copy, Debug)]
pub struct odd_t {
    d: [f32; 8],
}

impl odd_t {

    pub fn new(e1: f32, e2: f32, e3: f32, e0: f32, e032: f32, e013: f32, e021: f32, e123: f32) -> Self {
        let d = [e1, e2, e3, e0, e032, e013, e021, e123];
        Self { d }
    }
    pub fn e1(&self) -> f32 { self.d[0] }
    pub fn e2(&self) -> f32 { self.d[1] }
    pub fn e3(&self) -> f32 { self.d[2] }
    pub fn e0(&self) -> f32 { self.d[3] }
    pub fn e032(&self) -> f32 { self.d[4] }
    pub fn e013(&self) -> f32 { self.d[5] }
    pub fn e021(&self) -> f32 { self.d[6] }
    pub fn e123(&self) -> f32 { self.d[7] }
}


// Basis definitions
use once_cell::sync::Lazy;

pub mod basis {
    use super::*;
    pub static E1: Lazy<evector_t> = Lazy::new(|| evector_t::new(1.0, 0.0, 0.0));
    pub static E2: Lazy<evector_t> = Lazy::new(|| evector_t::new(0.0, 1.0, 0.0));
    pub static E3: Lazy<evector_t> = Lazy::new(|| evector_t::new(0.0, 0.0, 1.0));
    pub static E23: Lazy<ebivector_t> = Lazy::new(|| ebivector_t::new(1.0, 0.0, 0.0));
    pub static E31: Lazy<ebivector_t> = Lazy::new(|| ebivector_t::new(0.0, 1.0, 0.0));
    pub static E12: Lazy<ebivector_t> = Lazy::new(|| ebivector_t::new(0.0, 0.0, 1.0));
    pub static E01: Lazy<ibivector_t> = Lazy::new(|| ibivector_t::new(1.0, 0.0, 0.0));
    pub static E02: Lazy<ibivector_t> = Lazy::new(|| ibivector_t::new(0.0, 1.0, 0.0));
    pub static E03: Lazy<ibivector_t> = Lazy::new(|| ibivector_t::new(0.0, 0.0, 1.0));
    pub static E032: Lazy<direction_t> = Lazy::new(|| direction_t::new(1.0, 0.0, 0.0));
    pub static E013: Lazy<direction_t> = Lazy::new(|| direction_t::new(0.0, 1.0, 0.0));
    pub static E021: Lazy<direction_t> = Lazy::new(|| direction_t::new(0.0, 0.0, 1.0));
    pub static E0123: Lazy<quadvector_t> = Lazy::new(|| quadvector_t::new(1.0));
}

// Geometric Algebra functions
//
// Operator overloads are implemented via traits where possible.
// Mappings:
//   add  -> std::ops::Add ( + )
//   sub  -> std::ops::Sub ( - )
//   gp   -> std::ops::Mul ( * )
//   ip   -> std::ops::BitOr ( | )
//   op   -> std::ops::BitXor ( ^ )
//   rp   -> std::ops::BitAnd ( & )
//   dual -> std::ops::Not ( ! )
// For reverse, a method is generated.
pub mod geometric_algebra {
    use super::*;
    
////////////////////////////////////////////////////////////////////////////////  
// add between scalar and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<scalar_t> for bivector_t {
    type Output = even_t;
    fn add(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=self.d[3];
          res.d[5]=self.d[4];
          res.d[6]=self.d[5];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<scalar_t> for quadvector_t {
    type Output = even_t;
    fn add(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<scalar_t> for ebivector_t {
    type Output = rotation_t;
    fn add(self, rhs: scalar_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 0 adds
          res.d[0]=rhs;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<scalar_t> for ibivector_t {
    type Output = even_t;
    fn add(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<scalar_t> for rotation_t {
    type Output = rotation_t;
    fn add(self, rhs: scalar_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 1 adds
          res.d[0]=rhs+self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<scalar_t> for translation_t {
    type Output = even_t;
    fn add(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=1.0+rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<scalar_t> for even_t {
    type Output = even_t;
    fn add(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=rhs+self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for vector_t {
    type Output = vector_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<trivector_t> for vector_t {
    type Output = odd_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<horizon_t> for vector_t {
    type Output = vector_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0+self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<origin_t> for vector_t {
    type Output = odd_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<point_t> for vector_t {
    type Output = odd_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<direction_t> for vector_t {
    type Output = odd_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<evector_t> for vector_t {
    type Output = vector_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<dpoint_t> for vector_t {
    type Output = vector_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=1.0+self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<odd_t> for vector_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          res.d[6]=rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for bivector_t {
    type Output = bivector_t;
    fn add(self, rhs: bivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 6 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          res.d[4]=self.d[4]+rhs.d[4];
          res.d[5]=self.d[5]+rhs.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<quadvector_t> for bivector_t {
    type Output = even_t;
    fn add(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=self.d[3];
          res.d[5]=self.d[4];
          res.d[6]=self.d[5];
          res.d[7]=rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ebivector_t> for bivector_t {
    type Output = bivector_t;
    fn add(self, rhs: ebivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ibivector_t> for bivector_t {
    type Output = bivector_t;
    fn add(self, rhs: ibivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3]+rhs.d[0];
          res.d[4]=self.d[4]+rhs.d[1];
          res.d[5]=self.d[5]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<rotation_t> for bivector_t {
    type Output = even_t;
    fn add(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=rhs.d[0];
          res.d[1]=self.d[0]+rhs.d[1];
          res.d[2]=self.d[1]+rhs.d[2];
          res.d[3]=self.d[2]+rhs.d[3];
          res.d[4]=self.d[3];
          res.d[5]=self.d[4];
          res.d[6]=self.d[5];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<translation_t> for bivector_t {
    type Output = even_t;
    fn add(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=1.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=self.d[3]+rhs.d[0];
          res.d[5]=self.d[4]+rhs.d[1];
          res.d[6]=self.d[5]+rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<even_t> for bivector_t {
    type Output = even_t;
    fn add(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
          res.d[0]=rhs.d[0];
          res.d[1]=self.d[0]+rhs.d[1];
          res.d[2]=self.d[1]+rhs.d[2];
          res.d[3]=self.d[2]+rhs.d[3];
          res.d[4]=self.d[3]+rhs.d[4];
          res.d[5]=self.d[4]+rhs.d[5];
          res.d[6]=self.d[5]+rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<vector_t> for trivector_t {
    type Output = odd_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for trivector_t {
    type Output = trivector_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<horizon_t> for trivector_t {
    type Output = odd_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<origin_t> for trivector_t {
    type Output = trivector_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0+self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<point_t> for trivector_t {
    type Output = trivector_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=1.0+self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<direction_t> for trivector_t {
    type Output = trivector_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<evector_t> for trivector_t {
    type Output = odd_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<dpoint_t> for trivector_t {
    type Output = odd_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<odd_t> for trivector_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0]+rhs.d[4];
          res.d[5]=self.d[1]+rhs.d[5];
          res.d[6]=self.d[2]+rhs.d[6];
          res.d[7]=self.d[3]+rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<bivector_t> for quadvector_t {
    type Output = even_t;
    fn add(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=rhs.d[0];
          res.d[2]=rhs.d[1];
          res.d[3]=rhs.d[2];
          res.d[4]=rhs.d[3];
          res.d[5]=rhs.d[4];
          res.d[6]=rhs.d[5];
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for quadvector_t {
    type Output = quadvector_t;
    fn add(self, rhs: quadvector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0]+rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ebivector_t> for quadvector_t {
    type Output = even_t;
    fn add(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=rhs.d[0];
          res.d[2]=rhs.d[1];
          res.d[3]=rhs.d[2];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ibivector_t> for quadvector_t {
    type Output = even_t;
    fn add(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<rotation_t> for quadvector_t {
    type Output = even_t;
    fn add(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<translation_t> for quadvector_t {
    type Output = even_t;
    fn add(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<even_t> for quadvector_t {
    type Output = even_t;
    fn add(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          res.d[6]=rhs.d[6];
          res.d[7]=self.d[0]+rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<vector_t> for horizon_t {
    type Output = vector_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=1.0+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<trivector_t> for horizon_t {
    type Output = odd_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for horizon_t {
    type Output = vector_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=2.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<origin_t> for horizon_t {
    type Output = odd_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<point_t> for horizon_t {
    type Output = odd_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<direction_t> for horizon_t {
    type Output = odd_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<evector_t> for horizon_t {
    type Output = dpoint_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<dpoint_t> for horizon_t {
    type Output = vector_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=2.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<odd_t> for horizon_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=1.0+rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          res.d[6]=rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<vector_t> for origin_t {
    type Output = odd_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<trivector_t> for origin_t {
    type Output = trivector_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=1.0+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<horizon_t> for origin_t {
    type Output = odd_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for origin_t {
    type Output = trivector_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=2.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<point_t> for origin_t {
    type Output = trivector_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=2.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<direction_t> for origin_t {
    type Output = point_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<evector_t> for origin_t {
    type Output = odd_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<dpoint_t> for origin_t {
    type Output = odd_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=1.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<odd_t> for origin_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          res.d[6]=rhs.d[6];
          res.d[7]=1.0+rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<vector_t> for point_t {
    type Output = odd_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<trivector_t> for point_t {
    type Output = trivector_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=1.0+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<horizon_t> for point_t {
    type Output = odd_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<origin_t> for point_t {
    type Output = trivector_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=2.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for point_t {
    type Output = trivector_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=2.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<direction_t> for point_t {
    type Output = point_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<evector_t> for point_t {
    type Output = odd_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<dpoint_t> for point_t {
    type Output = odd_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<odd_t> for point_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0]+rhs.d[4];
          res.d[5]=self.d[1]+rhs.d[5];
          res.d[6]=self.d[2]+rhs.d[6];
          res.d[7]=1.0+rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<vector_t> for direction_t {
    type Output = odd_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<trivector_t> for direction_t {
    type Output = trivector_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<horizon_t> for direction_t {
    type Output = odd_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<origin_t> for direction_t {
    type Output = point_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<point_t> for direction_t {
    type Output = point_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for direction_t {
    type Output = direction_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<evector_t> for direction_t {
    type Output = odd_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<dpoint_t> for direction_t {
    type Output = odd_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<odd_t> for direction_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0]+rhs.d[4];
          res.d[5]=self.d[1]+rhs.d[5];
          res.d[6]=self.d[2]+rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<bivector_t> for ebivector_t {
    type Output = bivector_t;
    fn add(self, rhs: bivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<quadvector_t> for ebivector_t {
    type Output = even_t;
    fn add(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for ebivector_t {
    type Output = ebivector_t;
    fn add(self, rhs: ebivector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ibivector_t> for ebivector_t {
    type Output = bivector_t;
    fn add(self, rhs: ibivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=rhs.d[0];
          res.d[4]=rhs.d[1];
          res.d[5]=rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<rotation_t> for ebivector_t {
    type Output = rotation_t;
    fn add(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 3 adds
          res.d[0]=rhs.d[0];
          res.d[1]=self.d[0]+rhs.d[1];
          res.d[2]=self.d[1]+rhs.d[2];
          res.d[3]=self.d[2]+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<translation_t> for ebivector_t {
    type Output = even_t;
    fn add(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<even_t> for ebivector_t {
    type Output = even_t;
    fn add(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=rhs.d[0];
          res.d[1]=self.d[0]+rhs.d[1];
          res.d[2]=self.d[1]+rhs.d[2];
          res.d[3]=self.d[2]+rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          res.d[6]=rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<bivector_t> for ibivector_t {
    type Output = bivector_t;
    fn add(self, rhs: bivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 3 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=self.d[0]+rhs.d[3];
          res.d[4]=self.d[1]+rhs.d[4];
          res.d[5]=self.d[2]+rhs.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<quadvector_t> for ibivector_t {
    type Output = even_t;
    fn add(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ebivector_t> for ibivector_t {
    type Output = bivector_t;
    fn add(self, rhs: ebivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=self.d[0];
          res.d[4]=self.d[1];
          res.d[5]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for ibivector_t {
    type Output = ibivector_t;
    fn add(self, rhs: ibivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<rotation_t> for ibivector_t {
    type Output = even_t;
    fn add(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<translation_t> for ibivector_t {
    type Output = translation_t;
    fn add(self, rhs: translation_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<even_t> for ibivector_t {
    type Output = even_t;
    fn add(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0]+rhs.d[4];
          res.d[5]=self.d[1]+rhs.d[5];
          res.d[6]=self.d[2]+rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<vector_t> for evector_t {
    type Output = vector_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<trivector_t> for evector_t {
    type Output = odd_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=0.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<horizon_t> for evector_t {
    type Output = dpoint_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<origin_t> for evector_t {
    type Output = odd_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<point_t> for evector_t {
    type Output = odd_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=0.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<direction_t> for evector_t {
    type Output = odd_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=0.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for evector_t {
    type Output = evector_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<dpoint_t> for evector_t {
    type Output = dpoint_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<odd_t> for evector_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          res.d[6]=rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<vector_t> for dpoint_t {
    type Output = vector_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=1.0+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<trivector_t> for dpoint_t {
    type Output = odd_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<horizon_t> for dpoint_t {
    type Output = vector_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=2.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<origin_t> for dpoint_t {
    type Output = odd_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<point_t> for dpoint_t {
    type Output = odd_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<direction_t> for dpoint_t {
    type Output = odd_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0;
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<evector_t> for dpoint_t {
    type Output = dpoint_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for dpoint_t {
    type Output = vector_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=2.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<odd_t> for dpoint_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=1.0+rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          res.d[6]=rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<bivector_t> for rotation_t {
    type Output = even_t;
    fn add(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1]+rhs.d[0];
          res.d[2]=self.d[2]+rhs.d[1];
          res.d[3]=self.d[3]+rhs.d[2];
          res.d[4]=rhs.d[3];
          res.d[5]=rhs.d[4];
          res.d[6]=rhs.d[5];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<quadvector_t> for rotation_t {
    type Output = even_t;
    fn add(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ebivector_t> for rotation_t {
    type Output = rotation_t;
    fn add(self, rhs: ebivector_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1]+rhs.d[0];
          res.d[2]=self.d[2]+rhs.d[1];
          res.d[3]=self.d[3]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ibivector_t> for rotation_t {
    type Output = even_t;
    fn add(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for rotation_t {
    type Output = rotation_t;
    fn add(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<translation_t> for rotation_t {
    type Output = even_t;
    fn add(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=1.0+self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=rhs.d[0];
          res.d[5]=rhs.d[1];
          res.d[6]=rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<even_t> for rotation_t {
    type Output = even_t;
    fn add(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          res.d[4]=rhs.d[4];
          res.d[5]=rhs.d[5];
          res.d[6]=rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<bivector_t> for translation_t {
    type Output = even_t;
    fn add(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=1.0;
          res.d[1]=rhs.d[0];
          res.d[2]=rhs.d[1];
          res.d[3]=rhs.d[2];
          res.d[4]=self.d[0]+rhs.d[3];
          res.d[5]=self.d[1]+rhs.d[4];
          res.d[6]=self.d[2]+rhs.d[5];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<quadvector_t> for translation_t {
    type Output = even_t;
    fn add(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ebivector_t> for translation_t {
    type Output = even_t;
    fn add(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          res.d[1]=rhs.d[0];
          res.d[2]=rhs.d[1];
          res.d[3]=rhs.d[2];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ibivector_t> for translation_t {
    type Output = translation_t;
    fn add(self, rhs: ibivector_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<rotation_t> for translation_t {
    type Output = even_t;
    fn add(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=1.0+rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for translation_t {
    type Output = even_t;
    fn add(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=2.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[0]+rhs.d[0];
          res.d[5]=self.d[1]+rhs.d[1];
          res.d[6]=self.d[2]+rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<even_t> for translation_t {
    type Output = even_t;
    fn add(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=1.0+rhs.d[0];
          res.d[1]=rhs.d[1];
          res.d[2]=rhs.d[2];
          res.d[3]=rhs.d[3];
          res.d[4]=self.d[0]+rhs.d[4];
          res.d[5]=self.d[1]+rhs.d[5];
          res.d[6]=self.d[2]+rhs.d[6];
          res.d[7]=rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<bivector_t> for even_t {
    type Output = even_t;
    fn add(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1]+rhs.d[0];
          res.d[2]=self.d[2]+rhs.d[1];
          res.d[3]=self.d[3]+rhs.d[2];
          res.d[4]=self.d[4]+rhs.d[3];
          res.d[5]=self.d[5]+rhs.d[4];
          res.d[6]=self.d[6]+rhs.d[5];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<quadvector_t> for even_t {
    type Output = even_t;
    fn add(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7]+rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ebivector_t> for even_t {
    type Output = even_t;
    fn add(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1]+rhs.d[0];
          res.d[2]=self.d[2]+rhs.d[1];
          res.d[3]=self.d[3]+rhs.d[2];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<ibivector_t> for even_t {
    type Output = even_t;
    fn add(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]+rhs.d[0];
          res.d[5]=self.d[5]+rhs.d[1];
          res.d[6]=self.d[6]+rhs.d[2];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<rotation_t> for even_t {
    type Output = even_t;
    fn add(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<translation_t> for even_t {
    type Output = even_t;
    fn add(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=1.0+self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]+rhs.d[0];
          res.d[5]=self.d[5]+rhs.d[1];
          res.d[6]=self.d[6]+rhs.d[2];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for even_t {
    type Output = even_t;
    fn add(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          res.d[4]=self.d[4]+rhs.d[4];
          res.d[5]=self.d[5]+rhs.d[5];
          res.d[6]=self.d[6]+rhs.d[6];
          res.d[7]=self.d[7]+rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<vector_t> for odd_t {
    type Output = odd_t;
    fn add(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<trivector_t> for odd_t {
    type Output = odd_t;
    fn add(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]+rhs.d[0];
          res.d[5]=self.d[5]+rhs.d[1];
          res.d[6]=self.d[6]+rhs.d[2];
          res.d[7]=self.d[7]+rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<horizon_t> for odd_t {
    type Output = odd_t;
    fn add(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0+self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<origin_t> for odd_t {
    type Output = odd_t;
    fn add(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=1.0+self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<point_t> for odd_t {
    type Output = odd_t;
    fn add(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]+rhs.d[0];
          res.d[5]=self.d[5]+rhs.d[1];
          res.d[6]=self.d[6]+rhs.d[2];
          res.d[7]=1.0+self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<direction_t> for odd_t {
    type Output = odd_t;
    fn add(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]+rhs.d[0];
          res.d[5]=self.d[5]+rhs.d[1];
          res.d[6]=self.d[6]+rhs.d[2];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<evector_t> for odd_t {
    type Output = odd_t;
    fn add(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add<dpoint_t> for odd_t {
    type Output = odd_t;
    fn add(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=1.0+self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Add for odd_t {
    type Output = odd_t;
    fn add(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=self.d[0]+rhs.d[0];
          res.d[1]=self.d[1]+rhs.d[1];
          res.d[2]=self.d[2]+rhs.d[2];
          res.d[3]=self.d[3]+rhs.d[3];
          res.d[4]=self.d[4]+rhs.d[4];
          res.d[5]=self.d[5]+rhs.d[5];
          res.d[6]=self.d[6]+rhs.d[6];
          res.d[7]=self.d[7]+rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<scalar_t> for bivector_t {
    type Output = even_t;
    fn sub(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
          res.d[0]=rhs;
          res.d[1]=-self.d[0];
          res.d[2]=-self.d[1];
          res.d[3]=-self.d[2];
          res.d[4]=-self.d[3];
          res.d[5]=-self.d[4];
          res.d[6]=-self.d[5];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<scalar_t> for quadvector_t {
    type Output = even_t;
    fn sub(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<scalar_t> for ebivector_t {
    type Output = rotation_t;
    fn sub(self, rhs: scalar_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 3 adds
          res.d[0]=rhs;
          res.d[1]=-self.d[0];
          res.d[2]=-self.d[1];
          res.d[3]=-self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<scalar_t> for ibivector_t {
    type Output = even_t;
    fn sub(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-self.d[0];
          res.d[5]=-self.d[1];
          res.d[6]=-self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<scalar_t> for rotation_t {
    type Output = rotation_t;
    fn sub(self, rhs: scalar_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 4 adds
          res.d[0]=rhs-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<scalar_t> for translation_t {
    type Output = even_t;
    fn sub(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 5 adds
          res.d[0]=-1.0+rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-self.d[0];
          res.d[5]=-self.d[1];
          res.d[6]=-self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<scalar_t> for even_t {
    type Output = even_t;
    fn sub(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=rhs-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          res.d[4]=-self.d[4];
          res.d[5]=-self.d[5];
          res.d[6]=-self.d[6];
          res.d[7]=-self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for vector_t {
    type Output = vector_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<trivector_t> for vector_t {
    type Output = odd_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<horizon_t> for vector_t {
    type Output = vector_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 2 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=-1.0+self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<origin_t> for vector_t {
    type Output = odd_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<point_t> for vector_t {
    type Output = odd_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<direction_t> for vector_t {
    type Output = odd_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<evector_t> for vector_t {
    type Output = vector_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<dpoint_t> for vector_t {
    type Output = vector_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 5 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-1.0+self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<odd_t> for vector_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          res.d[6]=-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for bivector_t {
    type Output = bivector_t;
    fn sub(self, rhs: bivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 6 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          res.d[4]=self.d[4]-rhs.d[4];
          res.d[5]=self.d[5]-rhs.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<quadvector_t> for bivector_t {
    type Output = even_t;
    fn sub(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=self.d[3];
          res.d[5]=self.d[4];
          res.d[6]=self.d[5];
          res.d[7]=-rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ebivector_t> for bivector_t {
    type Output = bivector_t;
    fn sub(self, rhs: ebivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ibivector_t> for bivector_t {
    type Output = bivector_t;
    fn sub(self, rhs: ibivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3]-rhs.d[0];
          res.d[4]=self.d[4]-rhs.d[1];
          res.d[5]=self.d[5]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<rotation_t> for bivector_t {
    type Output = even_t;
    fn sub(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=self.d[0]-rhs.d[1];
          res.d[2]=self.d[1]-rhs.d[2];
          res.d[3]=self.d[2]-rhs.d[3];
          res.d[4]=self.d[3];
          res.d[5]=self.d[4];
          res.d[6]=self.d[5];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<translation_t> for bivector_t {
    type Output = even_t;
    fn sub(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-1.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=self.d[3]-rhs.d[0];
          res.d[5]=self.d[4]-rhs.d[1];
          res.d[6]=self.d[5]-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<even_t> for bivector_t {
    type Output = even_t;
    fn sub(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=self.d[0]-rhs.d[1];
          res.d[2]=self.d[1]-rhs.d[2];
          res.d[3]=self.d[2]-rhs.d[3];
          res.d[4]=self.d[3]-rhs.d[4];
          res.d[5]=self.d[4]-rhs.d[5];
          res.d[6]=self.d[5]-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<vector_t> for trivector_t {
    type Output = odd_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for trivector_t {
    type Output = trivector_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<horizon_t> for trivector_t {
    type Output = odd_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<origin_t> for trivector_t {
    type Output = trivector_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 2 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=-1.0+self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<point_t> for trivector_t {
    type Output = trivector_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 5 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-1.0+self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<direction_t> for trivector_t {
    type Output = trivector_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<evector_t> for trivector_t {
    type Output = odd_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<dpoint_t> for trivector_t {
    type Output = odd_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<odd_t> for trivector_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0]-rhs.d[4];
          res.d[5]=self.d[1]-rhs.d[5];
          res.d[6]=self.d[2]-rhs.d[6];
          res.d[7]=self.d[3]-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<bivector_t> for quadvector_t {
    type Output = even_t;
    fn sub(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
          res.d[0]=0.0;
          res.d[1]=-rhs.d[0];
          res.d[2]=-rhs.d[1];
          res.d[3]=-rhs.d[2];
          res.d[4]=-rhs.d[3];
          res.d[5]=-rhs.d[4];
          res.d[6]=-rhs.d[5];
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for quadvector_t {
    type Output = quadvector_t;
    fn sub(self, rhs: quadvector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0]-rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ebivector_t> for quadvector_t {
    type Output = even_t;
    fn sub(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=0.0;
          res.d[1]=-rhs.d[0];
          res.d[2]=-rhs.d[1];
          res.d[3]=-rhs.d[2];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ibivector_t> for quadvector_t {
    type Output = even_t;
    fn sub(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<rotation_t> for quadvector_t {
    type Output = even_t;
    fn sub(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<translation_t> for quadvector_t {
    type Output = even_t;
    fn sub(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-1.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<even_t> for quadvector_t {
    type Output = even_t;
    fn sub(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          res.d[6]=-rhs.d[6];
          res.d[7]=self.d[0]-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<vector_t> for horizon_t {
    type Output = vector_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=1.0-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<trivector_t> for horizon_t {
    type Output = odd_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for horizon_t {
    type Output = scalar_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        
            return 0.0;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<origin_t> for horizon_t {
    type Output = odd_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<point_t> for horizon_t {
    type Output = odd_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<direction_t> for horizon_t {
    type Output = odd_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=1.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<evector_t> for horizon_t {
    type Output = dpoint_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<dpoint_t> for horizon_t {
    type Output = evector_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<odd_t> for horizon_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=1.0-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          res.d[6]=-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<vector_t> for origin_t {
    type Output = odd_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<trivector_t> for origin_t {
    type Output = trivector_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=1.0-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<horizon_t> for origin_t {
    type Output = odd_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for origin_t {
    type Output = scalar_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        
            return 0.0;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<point_t> for origin_t {
    type Output = direction_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<direction_t> for origin_t {
    type Output = point_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<evector_t> for origin_t {
    type Output = odd_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<dpoint_t> for origin_t {
    type Output = odd_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-1.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<odd_t> for origin_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          res.d[6]=-rhs.d[6];
          res.d[7]=1.0-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<vector_t> for point_t {
    type Output = odd_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<trivector_t> for point_t {
    type Output = trivector_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=1.0-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<horizon_t> for point_t {
    type Output = odd_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<origin_t> for point_t {
    type Output = direction_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for point_t {
    type Output = direction_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<direction_t> for point_t {
    type Output = point_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<evector_t> for point_t {
    type Output = odd_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<dpoint_t> for point_t {
    type Output = odd_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<odd_t> for point_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0]-rhs.d[4];
          res.d[5]=self.d[1]-rhs.d[5];
          res.d[6]=self.d[2]-rhs.d[6];
          res.d[7]=1.0-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<vector_t> for direction_t {
    type Output = odd_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<trivector_t> for direction_t {
    type Output = trivector_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<horizon_t> for direction_t {
    type Output = odd_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<origin_t> for direction_t {
    type Output = trivector_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<point_t> for direction_t {
    type Output = trivector_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for direction_t {
    type Output = direction_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<evector_t> for direction_t {
    type Output = odd_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<dpoint_t> for direction_t {
    type Output = odd_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-1.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<odd_t> for direction_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0]-rhs.d[4];
          res.d[5]=self.d[1]-rhs.d[5];
          res.d[6]=self.d[2]-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<bivector_t> for ebivector_t {
    type Output = bivector_t;
    fn sub(self, rhs: bivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 6 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<quadvector_t> for ebivector_t {
    type Output = even_t;
    fn sub(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for ebivector_t {
    type Output = ebivector_t;
    fn sub(self, rhs: ebivector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ibivector_t> for ebivector_t {
    type Output = bivector_t;
    fn sub(self, rhs: ibivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=-rhs.d[0];
          res.d[4]=-rhs.d[1];
          res.d[5]=-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<rotation_t> for ebivector_t {
    type Output = rotation_t;
    fn sub(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=self.d[0]-rhs.d[1];
          res.d[2]=self.d[1]-rhs.d[2];
          res.d[3]=self.d[2]-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<translation_t> for ebivector_t {
    type Output = even_t;
    fn sub(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-1.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<even_t> for ebivector_t {
    type Output = even_t;
    fn sub(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=self.d[0]-rhs.d[1];
          res.d[2]=self.d[1]-rhs.d[2];
          res.d[3]=self.d[2]-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          res.d[6]=-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<bivector_t> for ibivector_t {
    type Output = bivector_t;
    fn sub(self, rhs: bivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 6 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=self.d[0]-rhs.d[3];
          res.d[4]=self.d[1]-rhs.d[4];
          res.d[5]=self.d[2]-rhs.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<quadvector_t> for ibivector_t {
    type Output = even_t;
    fn sub(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=-rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ebivector_t> for ibivector_t {
    type Output = bivector_t;
    fn sub(self, rhs: ebivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 3 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=self.d[0];
          res.d[4]=self.d[1];
          res.d[5]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for ibivector_t {
    type Output = ibivector_t;
    fn sub(self, rhs: ibivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<rotation_t> for ibivector_t {
    type Output = even_t;
    fn sub(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<translation_t> for ibivector_t {
    type Output = even_t;
    fn sub(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-1.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[0]-rhs.d[0];
          res.d[5]=self.d[1]-rhs.d[1];
          res.d[6]=self.d[2]-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<even_t> for ibivector_t {
    type Output = even_t;
    fn sub(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0]-rhs.d[4];
          res.d[5]=self.d[1]-rhs.d[5];
          res.d[6]=self.d[2]-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<vector_t> for evector_t {
    type Output = vector_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<trivector_t> for evector_t {
    type Output = odd_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=0.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<horizon_t> for evector_t {
    type Output = vector_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<origin_t> for evector_t {
    type Output = odd_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<point_t> for evector_t {
    type Output = odd_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=0.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<direction_t> for evector_t {
    type Output = odd_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=0.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for evector_t {
    type Output = evector_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<dpoint_t> for evector_t {
    type Output = vector_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<odd_t> for evector_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          res.d[6]=-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<vector_t> for dpoint_t {
    type Output = vector_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=1.0-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<trivector_t> for dpoint_t {
    type Output = odd_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<horizon_t> for dpoint_t {
    type Output = evector_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<origin_t> for dpoint_t {
    type Output = odd_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<point_t> for dpoint_t {
    type Output = odd_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<direction_t> for dpoint_t {
    type Output = odd_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=1.0;
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<evector_t> for dpoint_t {
    type Output = dpoint_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for dpoint_t {
    type Output = evector_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<odd_t> for dpoint_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=1.0-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          res.d[6]=-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<bivector_t> for rotation_t {
    type Output = even_t;
    fn sub(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1]-rhs.d[0];
          res.d[2]=self.d[2]-rhs.d[1];
          res.d[3]=self.d[3]-rhs.d[2];
          res.d[4]=-rhs.d[3];
          res.d[5]=-rhs.d[4];
          res.d[6]=-rhs.d[5];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<quadvector_t> for rotation_t {
    type Output = even_t;
    fn sub(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ebivector_t> for rotation_t {
    type Output = rotation_t;
    fn sub(self, rhs: ebivector_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1]-rhs.d[0];
          res.d[2]=self.d[2]-rhs.d[1];
          res.d[3]=self.d[3]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ibivector_t> for rotation_t {
    type Output = even_t;
    fn sub(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for rotation_t {
    type Output = rotation_t;
    fn sub(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<translation_t> for rotation_t {
    type Output = even_t;
    fn sub(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 5 adds
          res.d[0]=-1.0+self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=-rhs.d[0];
          res.d[5]=-rhs.d[1];
          res.d[6]=-rhs.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<even_t> for rotation_t {
    type Output = even_t;
    fn sub(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          res.d[4]=-rhs.d[4];
          res.d[5]=-rhs.d[5];
          res.d[6]=-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<bivector_t> for translation_t {
    type Output = even_t;
    fn sub(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
          res.d[0]=1.0;
          res.d[1]=-rhs.d[0];
          res.d[2]=-rhs.d[1];
          res.d[3]=-rhs.d[2];
          res.d[4]=self.d[0]-rhs.d[3];
          res.d[5]=self.d[1]-rhs.d[4];
          res.d[6]=self.d[2]-rhs.d[5];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<quadvector_t> for translation_t {
    type Output = even_t;
    fn sub(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=1.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=-rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ebivector_t> for translation_t {
    type Output = even_t;
    fn sub(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=1.0;
          res.d[1]=-rhs.d[0];
          res.d[2]=-rhs.d[1];
          res.d[3]=-rhs.d[2];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ibivector_t> for translation_t {
    type Output = translation_t;
    fn sub(self, rhs: ibivector_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<rotation_t> for translation_t {
    type Output = even_t;
    fn sub(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=1.0-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for translation_t {
    type Output = ibivector_t;
    fn sub(self, rhs: translation_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<even_t> for translation_t {
    type Output = even_t;
    fn sub(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=1.0-rhs.d[0];
          res.d[1]=-rhs.d[1];
          res.d[2]=-rhs.d[2];
          res.d[3]=-rhs.d[3];
          res.d[4]=self.d[0]-rhs.d[4];
          res.d[5]=self.d[1]-rhs.d[5];
          res.d[6]=self.d[2]-rhs.d[6];
          res.d[7]=-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<bivector_t> for even_t {
    type Output = even_t;
    fn sub(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1]-rhs.d[0];
          res.d[2]=self.d[2]-rhs.d[1];
          res.d[3]=self.d[3]-rhs.d[2];
          res.d[4]=self.d[4]-rhs.d[3];
          res.d[5]=self.d[5]-rhs.d[4];
          res.d[6]=self.d[6]-rhs.d[5];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<quadvector_t> for even_t {
    type Output = even_t;
    fn sub(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7]-rhs.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ebivector_t> for even_t {
    type Output = even_t;
    fn sub(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1]-rhs.d[0];
          res.d[2]=self.d[2]-rhs.d[1];
          res.d[3]=self.d[3]-rhs.d[2];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<ibivector_t> for even_t {
    type Output = even_t;
    fn sub(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]-rhs.d[0];
          res.d[5]=self.d[5]-rhs.d[1];
          res.d[6]=self.d[6]-rhs.d[2];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<rotation_t> for even_t {
    type Output = even_t;
    fn sub(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<translation_t> for even_t {
    type Output = even_t;
    fn sub(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 5 adds
          res.d[0]=-1.0+self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]-rhs.d[0];
          res.d[5]=self.d[5]-rhs.d[1];
          res.d[6]=self.d[6]-rhs.d[2];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for even_t {
    type Output = even_t;
    fn sub(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 8 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          res.d[4]=self.d[4]-rhs.d[4];
          res.d[5]=self.d[5]-rhs.d[5];
          res.d[6]=self.d[6]-rhs.d[6];
          res.d[7]=self.d[7]-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<vector_t> for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<trivector_t> for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]-rhs.d[0];
          res.d[5]=self.d[5]-rhs.d[1];
          res.d[6]=self.d[6]-rhs.d[2];
          res.d[7]=self.d[7]-rhs.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<horizon_t> for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 2 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=-1.0+self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<origin_t> for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 2 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=-1.0+self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<point_t> for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 5 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]-rhs.d[0];
          res.d[5]=self.d[5]-rhs.d[1];
          res.d[6]=self.d[6]-rhs.d[2];
          res.d[7]=-1.0+self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<direction_t> for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4]-rhs.d[0];
          res.d[5]=self.d[5]-rhs.d[1];
          res.d[6]=self.d[6]-rhs.d[2];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<evector_t> for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub<dpoint_t> for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 5 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=-1.0+self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Sub for odd_t {
    type Output = odd_t;
    fn sub(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=self.d[0]-rhs.d[0];
          res.d[1]=self.d[1]-rhs.d[1];
          res.d[2]=self.d[2]-rhs.d[2];
          res.d[3]=self.d[3]-rhs.d[3];
          res.d[4]=self.d[4]-rhs.d[4];
          res.d[5]=self.d[5]-rhs.d[5];
          res.d[6]=self.d[6]-rhs.d[6];
          res.d[7]=self.d[7]-rhs.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for vector_t {
    type Output = vector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for bivector_t {
    type Output = bivector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for trivector_t {
    type Output = trivector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for quadvector_t {
    type Output = quadvector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // rhs
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
          let b0=self.d[0];
          res.d[0]=rhs*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for horizon_t {
    type Output = vector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for origin_t {
    type Output = trivector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for point_t {
    type Output = trivector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for direction_t {
    type Output = direction_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for ebivector_t {
    type Output = ebivector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for ibivector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for evector_t {
    type Output = evector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for dpoint_t {
    type Output = vector_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for rotation_t {
    type Output = rotation_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for translation_t {
    type Output = even_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=rhs*b0;
          res.d[5]=rhs*b1;
          res.d[6]=rhs*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for even_t {
    type Output = even_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 8 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
        let b6=self.d[6];
        let b7=self.d[7];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          res.d[6]=rhs*b6;
          res.d[7]=rhs*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<scalar_t> for odd_t {
    type Output = odd_t;
    fn mul(self, rhs: scalar_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 8 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
        let b6=self.d[6];
        let b7=self.d[7];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          res.d[6]=rhs*b6;
          res.d[7]=rhs*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for vector_t {
    type Output = even_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 15 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=a3*b0-a0*b3;
          res.d[5]=a3*b1-a1*b3;
          res.d[6]=a3*b2-a2*b3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for vector_t {
    type Output = odd_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 21 muls / 14 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          res.d[4]=a1*b5-a2*b4-a3*b0;
          res.d[5]=a2*b3-a0*b5-a3*b1;
          res.d[6]=a0*b4-a1*b3-a3*b2;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for vector_t {
    type Output = even_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 13 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=a0*b3;
          res.d[2]=a1*b3;
          res.d[3]=a2*b3;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2+a3*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for vector_t {
    type Output = direction_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for vector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for vector_t {
    type Output = even_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for vector_t {
    type Output = even_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2+a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for vector_t {
    type Output = even_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for vector_t {
    type Output = odd_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=0.0;
          res.d[4]=-a3*b0;
          res.d[5]=-a3*b1;
          res.d[6]=-a3*b2;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for vector_t {
    type Output = odd_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for vector_t {
    type Output = even_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=a3*b0;
          res.d[5]=a3*b1;
          res.d[6]=a3*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for vector_t {
    type Output = even_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=a3*b0-a0;
          res.d[5]=a3*b1-a1;
          res.d[6]=a3*b2-a2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for vector_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=a3*b0;
          res.d[4]=-a3*b1;
          res.d[5]=-a3*b2;
          res.d[6]=-a3*b3;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for vector_t {
    type Output = odd_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3-a0*b0-a1*b1-a2*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for vector_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 28 muls / 20 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=a3*b0-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7+a1*b6-a2*b5-a3*b1;
          res.d[5]=a1*b7+a2*b4-a0*b6-a3*b2;
          res.d[6]=a0*b5+a2*b7-a1*b4-a3*b3;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for vector_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 28 muls / 20 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a0*b7+a1*b2-a2*b1;
          res.d[2]=a1*b7+a2*b0-a0*b2;
          res.d[3]=a0*b1+a2*b7-a1*b0;
          res.d[4]=a2*b5+a3*b0-a0*b3-a1*b6;
          res.d[5]=a0*b6+a3*b1-a1*b3-a2*b4;
          res.d[6]=a1*b4+a3*b2-a0*b5-a2*b3;
          res.d[7]=a0*b4+a1*b5+a2*b6+a3*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for bivector_t {
    type Output = odd_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 21 muls / 13 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=a3*b0+a4*b1+a5*b2;
          res.d[4]=a5*b1-a0*b3-a4*b2;
          res.d[5]=a3*b2-a1*b3-a5*b0;
          res.d[6]=a4*b0-a2*b3-a3*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for bivector_t {
    type Output = even_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 27 muls / 20 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          res.d[1]=a2*b1-a1*b2;
          res.d[2]=a0*b2-a2*b0;
          res.d[3]=a1*b0-a0*b1;
          res.d[4]=a2*b4+a5*b1-a1*b5-a4*b2;
          res.d[5]=a0*b5+a3*b2-a2*b3-a5*b0;
          res.d[6]=a1*b3+a4*b0-a0*b4-a3*b1;
          res.d[7]=a0*b3+a1*b4+a2*b5+a3*b0+a4*b1+a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for bivector_t {
    type Output = odd_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 15 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b3;
          res.d[1]=-a1*b3;
          res.d[2]=-a2*b3;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2-a3*b3;
          res.d[5]=a0*b2-a2*b0-a4*b3;
          res.d[6]=a1*b0-a0*b1-a5*b3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for bivector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=-a0*b0;
          res.d[1]=-a1*b0;
          res.d[2]=-a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for bivector_t {
    type Output = direction_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for bivector_t {
    type Output = odd_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=0.0;
          res.d[4]=-a3;
          res.d[5]=-a4;
          res.d[6]=-a5;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for bivector_t {
    type Output = odd_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2-a3;
          res.d[5]=a0*b2-a2*b0-a4;
          res.d[6]=a1*b0-a0*b1-a5;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for bivector_t {
    type Output = odd_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for bivector_t {
    type Output = even_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 18 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          res.d[1]=a2*b1-a1*b2;
          res.d[2]=a0*b2-a2*b0;
          res.d[3]=a1*b0-a0*b1;
          res.d[4]=a5*b1-a4*b2;
          res.d[5]=a3*b2-a5*b0;
          res.d[6]=a4*b0-a3*b1;
          res.d[7]=a3*b0+a4*b1+a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for bivector_t {
    type Output = even_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for bivector_t {
    type Output = odd_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 18 muls / 10 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=a3*b0+a4*b1+a5*b2;
          res.d[4]=a5*b1-a4*b2;
          res.d[5]=a3*b2-a5*b0;
          res.d[6]=a4*b0-a3*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for bivector_t {
    type Output = odd_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 18 muls / 13 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=a3*b0+a4*b1+a5*b2;
          res.d[4]=a5*b1-a0-a4*b2;
          res.d[5]=a3*b2-a1-a5*b0;
          res.d[6]=a4*b0-a2-a3*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for bivector_t {
    type Output = even_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 17 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b1-a1*b2-a2*b3;
          res.d[1]=a0*b0+a2*b2-a1*b3;
          res.d[2]=a0*b3+a1*b0-a2*b1;
          res.d[3]=a1*b1+a2*b0-a0*b2;
          res.d[4]=a3*b0+a5*b2-a4*b3;
          res.d[5]=a3*b3+a4*b0-a5*b1;
          res.d[6]=a4*b1+a5*b0-a3*b2;
          res.d[7]=a3*b1+a4*b2+a5*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for bivector_t {
    type Output = even_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a2*b1+a3-a1*b2;
          res.d[5]=a0*b2+a4-a2*b0;
          res.d[6]=a1*b0+a5-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for bivector_t {
    type Output = even_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 36 muls / 29 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-a0*b1-a1*b2-a2*b3;
          res.d[1]=a0*b0+a2*b2-a1*b3;
          res.d[2]=a0*b3+a1*b0-a2*b1;
          res.d[3]=a1*b1+a2*b0-a0*b2;
          res.d[4]=a2*b5+a3*b0+a5*b2-a0*b7-a1*b6-a4*b3;
          res.d[5]=a0*b6+a3*b3+a4*b0-a1*b7-a2*b4-a5*b1;
          res.d[6]=a1*b4+a4*b1+a5*b0-a0*b5-a2*b7-a3*b2;
          res.d[7]=a0*b4+a1*b5+a2*b6+a3*b1+a4*b2+a5*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for bivector_t {
    type Output = odd_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 36 muls / 28 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a2*b1-a0*b7-a1*b2;
          res.d[1]=a0*b2-a1*b7-a2*b0;
          res.d[2]=a1*b0-a0*b1-a2*b7;
          res.d[3]=a0*b4+a1*b5+a2*b6+a3*b0+a4*b1+a5*b2;
          res.d[4]=a2*b5+a5*b1-a0*b3-a1*b6-a3*b7-a4*b2;
          res.d[5]=a0*b6+a3*b2-a1*b3-a2*b4-a4*b7-a5*b0;
          res.d[6]=a1*b4+a4*b0-a0*b5-a2*b3-a3*b1-a5*b7;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for trivector_t {
    type Output = even_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 13 muls / 7 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=a3*b0;
          res.d[2]=a3*b1;
          res.d[3]=a3*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2-a3*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for trivector_t {
    type Output = odd_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 15 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-a3*b0;
          res.d[1]=-a3*b1;
          res.d[2]=-a3*b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1+a3*b3-a1*b2;
          res.d[5]=a0*b2+a3*b4-a2*b0;
          res.d[6]=a1*b0+a3*b5-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for trivector_t {
    type Output = even_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 7 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a3*b3;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b3-a3*b0;
          res.d[5]=a1*b3-a3*b1;
          res.d[6]=a2*b3-a3*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for trivector_t {
    type Output = vector_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 1 muls / 0 adds
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for trivector_t {
    type Output = quadvector_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₀
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          let a3=self.d[3];
          res.d[0]=-a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for trivector_t {
    type Output = even_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=-a3;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0;
          res.d[5]=a1;
          res.d[6]=a2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for trivector_t {
    type Output = even_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a3;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0-a3*b0;
          res.d[5]=a1-a3*b1;
          res.d[6]=a2-a3*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for trivector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a3*b0;
          res.d[1]=-a3*b1;
          res.d[2]=-a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for trivector_t {
    type Output = odd_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a3*b0;
          res.d[1]=-a3*b1;
          res.d[2]=-a3*b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for trivector_t {
    type Output = direction_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0;
          res.d[1]=a3*b1;
          res.d[2]=a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for trivector_t {
    type Output = even_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a3*b0;
          res.d[2]=a3*b1;
          res.d[3]=a3*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for trivector_t {
    type Output = even_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 7 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a3*b0;
          res.d[2]=a3*b1;
          res.d[3]=a3*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2-a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for trivector_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a3*b1;
          res.d[1]=-a3*b2;
          res.d[2]=-a3*b3;
          res.d[3]=a0*b1+a1*b2+a2*b3;
          res.d[4]=a0*b0+a2*b2-a1*b3;
          res.d[5]=a0*b3+a1*b0-a2*b1;
          res.d[6]=a1*b1+a2*b0-a0*b2;
          res.d[7]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for trivector_t {
    type Output = trivector_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0+a3*b0;
          res.d[1]=a1+a3*b1;
          res.d[2]=a2+a3*b2;
          res.d[3]=a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for trivector_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 20 muls / 15 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-a3*b1;
          res.d[1]=-a3*b2;
          res.d[2]=-a3*b3;
          res.d[3]=a0*b1+a1*b2+a2*b3+a3*b7;
          res.d[4]=a0*b0+a2*b2+a3*b4-a1*b3;
          res.d[5]=a0*b3+a1*b0+a3*b5-a2*b1;
          res.d[6]=a1*b1+a2*b0+a3*b6-a0*b2;
          res.d[7]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for trivector_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 20 muls / 14 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-a3*b7;
          res.d[1]=a3*b0;
          res.d[2]=a3*b1;
          res.d[3]=a3*b2;
          res.d[4]=a0*b7+a1*b2-a2*b1-a3*b4;
          res.d[5]=a1*b7+a2*b0-a0*b2-a3*b5;
          res.d[6]=a0*b1+a2*b7-a1*b0-a3*b6;
          res.d[7]=-a0*b0-a1*b1-a2*b2-a3*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for quadvector_t {
    type Output = direction_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for quadvector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for quadvector_t {
    type Output = vector_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 1 muls / 1 adds
        let a0=self.d[0];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for quadvector_t {
    type Output = scalar_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for quadvector_t {
    type Output = scalar_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for quadvector_t {
    type Output = vector_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for quadvector_t {
    type Output = vector_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for quadvector_t {
    type Output = scalar_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for quadvector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for quadvector_t {
    type Output = scalar_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for quadvector_t {
    type Output = direction_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for quadvector_t {
    type Output = direction_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for quadvector_t {
    type Output = even_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a0*b1;
          res.d[5]=-a0*b2;
          res.d[6]=-a0*b3;
          res.d[7]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for quadvector_t {
    type Output = quadvector_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for quadvector_t {
    type Output = even_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a0*b1;
          res.d[5]=-a0*b2;
          res.d[6]=-a0*b3;
          res.d[7]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for quadvector_t {
    type Output = odd_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 4 muls / 4 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b7;
          res.d[4]=-a0*b0;
          res.d[5]=-a0*b1;
          res.d[6]=-a0*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for horizon_t {
    type Output = ibivector_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for horizon_t {
    type Output = direction_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for horizon_t {
    type Output = quadvector_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let b3=rhs.d[3];
          res.d[0]=b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for horizon_t {
    type Output = scalar_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for horizon_t {
    type Output = scalar_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        
          // 1 e₀
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for horizon_t {
    type Output = quadvector_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₀
          // 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for horizon_t {
    type Output = quadvector_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for horizon_t {
    type Output = scalar_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for horizon_t {
    type Output = direction_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for horizon_t {
    type Output = scalar_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for horizon_t {
    type Output = ibivector_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for horizon_t {
    type Output = ibivector_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for horizon_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          res.d[4]=-b1;
          res.d[5]=-b2;
          res.d[6]=-b3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for horizon_t {
    type Output = horizon_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = horizon_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for horizon_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          res.d[4]=-b1;
          res.d[5]=-b2;
          res.d[6]=-b3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for horizon_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=b0;
          res.d[5]=b1;
          res.d[6]=b2;
          res.d[7]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for origin_t {
    type Output = even_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for origin_t {
    type Output = odd_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          res.d[3]=0.0;
          res.d[4]=b3;
          res.d[5]=b4;
          res.d[6]=b5;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for origin_t {
    type Output = even_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-b3;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-b0;
          res.d[5]=-b1;
          res.d[6]=-b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for origin_t {
    type Output = vector_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for origin_t {
    type Output = quadvector_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₁₂₃
          // 1 e₀
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for origin_t {
    type Output = scalar_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        
          // 1 e₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          return -1.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for origin_t {
    type Output = even_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-1.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-b0;
          res.d[5]=-b1;
          res.d[6]=-b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for origin_t {
    type Output = ibivector_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for origin_t {
    type Output = evector_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for origin_t {
    type Output = direction_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for origin_t {
    type Output = ebivector_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for origin_t {
    type Output = even_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for origin_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-b1;
          res.d[1]=-b2;
          res.d[2]=-b3;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for origin_t {
    type Output = point_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for origin_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-b1;
          res.d[1]=-b2;
          res.d[2]=-b3;
          res.d[3]=b7;
          res.d[4]=b4;
          res.d[5]=b5;
          res.d[6]=b6;
          res.d[7]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for origin_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 5 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-b7;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=-b4;
          res.d[5]=-b5;
          res.d[6]=-b6;
          res.d[7]=-b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for point_t {
    type Output = even_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 7 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2-b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for point_t {
    type Output = odd_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1+b3-a1*b2;
          res.d[5]=a0*b2+b4-a2*b0;
          res.d[6]=a1*b0+b5-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for point_t {
    type Output = even_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-b3;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b3-b0;
          res.d[5]=a1*b3-b1;
          res.d[6]=a2*b3-b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for point_t {
    type Output = vector_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for point_t {
    type Output = quadvector_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₀
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for point_t {
    type Output = even_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-1.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0;
          res.d[5]=a1;
          res.d[6]=a2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for point_t {
    type Output = even_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-1.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0-b0;
          res.d[5]=a1-b1;
          res.d[6]=a2-b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for point_t {
    type Output = ibivector_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for point_t {
    type Output = odd_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for point_t {
    type Output = direction_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for point_t {
    type Output = even_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for point_t {
    type Output = even_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 7 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-1.0-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for point_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-b1;
          res.d[1]=-b2;
          res.d[2]=-b3;
          res.d[3]=a0*b1+a1*b2+a2*b3;
          res.d[4]=a0*b0+a2*b2-a1*b3;
          res.d[5]=a0*b3+a1*b0-a2*b1;
          res.d[6]=a1*b1+a2*b0-a0*b2;
          res.d[7]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for point_t {
    type Output = point_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0+b0;
          res.d[1]=a1+b1;
          res.d[2]=a2+b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for point_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 15 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-b1;
          res.d[1]=-b2;
          res.d[2]=-b3;
          res.d[3]=a0*b1+a1*b2+a2*b3+b7;
          res.d[4]=a0*b0+a2*b2+b4-a1*b3;
          res.d[5]=a0*b3+a1*b0+b5-a2*b1;
          res.d[6]=a1*b1+a2*b0+b6-a0*b2;
          res.d[7]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for point_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 14 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-b7;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=a0*b7+a1*b2-a2*b1-b4;
          res.d[5]=a1*b7+a2*b0-a0*b2-b5;
          res.d[6]=a0*b1+a2*b7-a1*b0-b6;
          res.d[7]=-a0*b0-a1*b1-a2*b2-b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for direction_t {
    type Output = even_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for direction_t {
    type Output = odd_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for direction_t {
    type Output = ibivector_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b3;
          res.d[1]=a1*b3;
          res.d[2]=a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for direction_t {
    type Output = scalar_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for direction_t {
    type Output = scalar_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for direction_t {
    type Output = ibivector_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for direction_t {
    type Output = ibivector_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for direction_t {
    type Output = scalar_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for direction_t {
    type Output = odd_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for direction_t {
    type Output = scalar_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for direction_t {
    type Output = even_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for direction_t {
    type Output = even_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for direction_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b1+a1*b2+a2*b3;
          res.d[4]=a0*b0+a2*b2-a1*b3;
          res.d[5]=a0*b3+a1*b0-a2*b1;
          res.d[6]=a1*b1+a2*b0-a0*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for direction_t {
    type Output = direction_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for direction_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b1+a1*b2+a2*b3;
          res.d[4]=a0*b0+a2*b2-a1*b3;
          res.d[5]=a0*b3+a1*b0-a2*b1;
          res.d[6]=a1*b1+a2*b0-a0*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for direction_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b7+a1*b2-a2*b1;
          res.d[5]=a1*b7+a2*b0-a0*b2;
          res.d[6]=a0*b1+a2*b7-a1*b0;
          res.d[7]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for ebivector_t {
    type Output = odd_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=0.0;
          res.d[4]=-a0*b3;
          res.d[5]=-a1*b3;
          res.d[6]=-a2*b3;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for ebivector_t {
    type Output = even_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 18 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          res.d[1]=a2*b1-a1*b2;
          res.d[2]=a0*b2-a2*b0;
          res.d[3]=a1*b0-a0*b1;
          res.d[4]=a2*b4-a1*b5;
          res.d[5]=a0*b5-a2*b3;
          res.d[6]=a1*b3-a0*b4;
          res.d[7]=a0*b3+a1*b4+a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for ebivector_t {
    type Output = odd_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b3;
          res.d[1]=-a1*b3;
          res.d[2]=-a2*b3;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for ebivector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=-a0*b0;
          res.d[1]=-a1*b0;
          res.d[2]=-a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for ebivector_t {
    type Output = direction_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for ebivector_t {
    type Output = evector_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for ebivector_t {
    type Output = odd_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for ebivector_t {
    type Output = odd_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for ebivector_t {
    type Output = rotation_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          res.d[1]=a2*b1-a1*b2;
          res.d[2]=a0*b2-a2*b0;
          res.d[3]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for ebivector_t {
    type Output = even_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for ebivector_t {
    type Output = odd_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for ebivector_t {
    type Output = odd_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=0.0;
          res.d[4]=-a0;
          res.d[5]=-a1;
          res.d[6]=-a2;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for ebivector_t {
    type Output = rotation_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b1-a1*b2-a2*b3;
          res.d[1]=a0*b0+a2*b2-a1*b3;
          res.d[2]=a0*b3+a1*b0-a2*b1;
          res.d[3]=a1*b1+a2*b0-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for ebivector_t {
    type Output = even_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for ebivector_t {
    type Output = even_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 17 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-a0*b1-a1*b2-a2*b3;
          res.d[1]=a0*b0+a2*b2-a1*b3;
          res.d[2]=a0*b3+a1*b0-a2*b1;
          res.d[3]=a1*b1+a2*b0-a0*b2;
          res.d[4]=a2*b5-a0*b7-a1*b6;
          res.d[5]=a0*b6-a1*b7-a2*b4;
          res.d[6]=a1*b4-a0*b5-a2*b7;
          res.d[7]=a0*b4+a1*b5+a2*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for ebivector_t {
    type Output = odd_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 24 muls / 16 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a2*b1-a0*b7-a1*b2;
          res.d[1]=a0*b2-a1*b7-a2*b0;
          res.d[2]=a1*b0-a0*b1-a2*b7;
          res.d[3]=a0*b4+a1*b5+a2*b6;
          res.d[4]=a2*b5-a0*b3-a1*b6;
          res.d[5]=a0*b6-a1*b3-a2*b4;
          res.d[6]=a1*b4-a0*b5-a2*b3;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for ibivector_t {
    type Output = odd_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for ibivector_t {
    type Output = even_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for ibivector_t {
    type Output = direction_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b3;
          res.d[1]=-a1*b3;
          res.d[2]=-a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for ibivector_t {
    type Output = scalar_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for ibivector_t {
    type Output = scalar_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for ibivector_t {
    type Output = direction_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for ibivector_t {
    type Output = direction_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for ibivector_t {
    type Output = scalar_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for ibivector_t {
    type Output = even_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for ibivector_t {
    type Output = scalar_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for ibivector_t {
    type Output = odd_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for ibivector_t {
    type Output = odd_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for ibivector_t {
    type Output = even_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0+a2*b2-a1*b3;
          res.d[5]=a0*b3+a1*b0-a2*b1;
          res.d[6]=a1*b1+a2*b0-a0*b2;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for ibivector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for ibivector_t {
    type Output = even_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0+a2*b2-a1*b3;
          res.d[5]=a0*b3+a1*b0-a2*b1;
          res.d[6]=a1*b1+a2*b0-a0*b2;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for ibivector_t {
    type Output = odd_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a0*b7-a1*b2;
          res.d[5]=a0*b2-a1*b7-a2*b0;
          res.d[6]=a1*b0-a0*b1-a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for evector_t {
    type Output = even_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=-a0*b3;
          res.d[5]=-a1*b3;
          res.d[6]=-a2*b3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for evector_t {
    type Output = odd_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 18 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          res.d[4]=a1*b5-a2*b4;
          res.d[5]=a2*b3-a0*b5;
          res.d[6]=a0*b4-a1*b3;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for evector_t {
    type Output = even_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=a0*b3;
          res.d[2]=a1*b3;
          res.d[3]=a2*b3;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for evector_t {
    type Output = direction_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for evector_t {
    type Output = ibivector_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for evector_t {
    type Output = ebivector_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for evector_t {
    type Output = even_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for evector_t {
    type Output = even_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for evector_t {
    type Output = odd_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for evector_t {
    type Output = odd_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for evector_t {
    type Output = rotation_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for evector_t {
    type Output = even_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=-a0;
          res.d[5]=-a1;
          res.d[6]=-a2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for evector_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for evector_t {
    type Output = odd_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for evector_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 24 muls / 17 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7+a1*b6-a2*b5;
          res.d[5]=a1*b7+a2*b4-a0*b6;
          res.d[6]=a0*b5+a2*b7-a1*b4;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for evector_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 16 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a0*b7+a1*b2-a2*b1;
          res.d[2]=a1*b7+a2*b0-a0*b2;
          res.d[3]=a0*b1+a2*b7-a1*b0;
          res.d[4]=a2*b5-a0*b3-a1*b6;
          res.d[5]=a0*b6-a1*b3-a2*b4;
          res.d[6]=a1*b4-a0*b5-a2*b3;
          res.d[7]=a0*b4+a1*b5+a2*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for dpoint_t {
    type Output = even_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=b0-a0*b3;
          res.d[5]=b1-a1*b3;
          res.d[6]=b2-a2*b3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for dpoint_t {
    type Output = odd_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 18 muls / 14 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          res.d[4]=a1*b5-a2*b4-b0;
          res.d[5]=a2*b3-a0*b5-b1;
          res.d[6]=a0*b4-a1*b3-b2;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for dpoint_t {
    type Output = even_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=a0*b3;
          res.d[2]=a1*b3;
          res.d[3]=a2*b3;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2+b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for dpoint_t {
    type Output = direction_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for dpoint_t {
    type Output = ibivector_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for dpoint_t {
    type Output = even_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for dpoint_t {
    type Output = even_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=1.0+a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for dpoint_t {
    type Output = even_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for dpoint_t {
    type Output = odd_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=0.0;
          res.d[4]=-b0;
          res.d[5]=-b1;
          res.d[6]=-b2;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for dpoint_t {
    type Output = odd_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for dpoint_t {
    type Output = even_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=b0;
          res.d[5]=b1;
          res.d[6]=b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for dpoint_t {
    type Output = even_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=b0-a0;
          res.d[5]=b1-a1;
          res.d[6]=b2-a2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for dpoint_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=b0;
          res.d[4]=-b1;
          res.d[5]=-b2;
          res.d[6]=-b3;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for dpoint_t {
    type Output = odd_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=1.0-a0*b0-a1*b1-a2*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for dpoint_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 24 muls / 20 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=b0-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7+a1*b6-a2*b5-b1;
          res.d[5]=a1*b7+a2*b4-a0*b6-b2;
          res.d[6]=a0*b5+a2*b7-a1*b4-b3;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for dpoint_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 20 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a0*b7+a1*b2-a2*b1;
          res.d[2]=a1*b7+a2*b0-a0*b2;
          res.d[3]=a0*b1+a2*b7-a1*b0;
          res.d[4]=a2*b5+b0-a0*b3-a1*b6;
          res.d[5]=a0*b6+b1-a1*b3-a2*b4;
          res.d[6]=a1*b4+b2-a0*b5-a2*b3;
          res.d[7]=a0*b4+a1*b5+a2*b6+b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a0*b3;
          res.d[4]=-a1*b3;
          res.d[5]=-a2*b3;
          res.d[6]=-a3*b3;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for rotation_t {
    type Output = even_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 17 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-a1*b0-a2*b1-a3*b2;
          res.d[1]=a0*b0+a3*b1-a2*b2;
          res.d[2]=a0*b1+a1*b2-a3*b0;
          res.d[3]=a0*b2+a2*b0-a1*b1;
          res.d[4]=a0*b3+a3*b4-a2*b5;
          res.d[5]=a0*b4+a1*b5-a3*b3;
          res.d[6]=a0*b5+a2*b3-a1*b4;
          res.d[7]=a1*b3+a2*b4+a3*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a1*b3;
          res.d[1]=-a2*b3;
          res.d[2]=-a3*b3;
          res.d[3]=a1*b0+a2*b1+a3*b2;
          res.d[4]=a0*b0+a3*b1-a2*b2;
          res.d[5]=a0*b1+a1*b2-a3*b0;
          res.d[6]=a0*b2+a2*b0-a1*b1;
          res.d[7]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for rotation_t {
    type Output = even_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a1*b0;
          res.d[5]=-a2*b0;
          res.d[6]=-a3*b0;
          res.d[7]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          res.d[4]=-a1;
          res.d[5]=-a2;
          res.d[6]=-a3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=-a1;
          res.d[1]=-a2;
          res.d[2]=-a3;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a1;
          res.d[1]=-a2;
          res.d[2]=-a3;
          res.d[3]=a1*b0+a2*b1+a3*b2;
          res.d[4]=a0*b0+a3*b1-a2*b2;
          res.d[5]=a0*b1+a1*b2-a3*b0;
          res.d[6]=a0*b2+a2*b0-a1*b1;
          res.d[7]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a1*b0+a2*b1+a3*b2;
          res.d[4]=a0*b0+a3*b1-a2*b2;
          res.d[5]=a0*b1+a1*b2-a3*b0;
          res.d[6]=a0*b2+a2*b0-a1*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for rotation_t {
    type Output = rotation_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a1*b0-a2*b1-a3*b2;
          res.d[1]=a0*b0+a3*b1-a2*b2;
          res.d[2]=a0*b1+a1*b2-a3*b0;
          res.d[3]=a0*b2+a2*b0-a1*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for rotation_t {
    type Output = even_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0+a3*b1-a2*b2;
          res.d[5]=a0*b1+a1*b2-a3*b0;
          res.d[6]=a0*b2+a2*b0-a1*b1;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a0;
          res.d[4]=-a1;
          res.d[5]=-a2;
          res.d[6]=-a3;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for rotation_t {
    type Output = rotation_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 16 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a0*b1+a1*b0+a3*b2-a2*b3;
          res.d[2]=a0*b2+a1*b3+a2*b0-a3*b1;
          res.d[3]=a0*b3+a2*b1+a3*b0-a1*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for rotation_t {
    type Output = even_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a0*b0+a3*b1-a2*b2;
          res.d[5]=a0*b1+a1*b2-a3*b0;
          res.d[6]=a0*b2+a2*b0-a1*b1;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for rotation_t {
    type Output = even_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 32 muls / 24 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a0*b1+a1*b0+a3*b2-a2*b3;
          res.d[2]=a0*b2+a1*b3+a2*b0-a3*b1;
          res.d[3]=a0*b3+a2*b1+a3*b0-a1*b2;
          res.d[4]=a0*b4+a3*b5-a1*b7-a2*b6;
          res.d[5]=a0*b5+a1*b6-a2*b7-a3*b4;
          res.d[6]=a0*b6+a2*b4-a1*b5-a3*b7;
          res.d[7]=a0*b7+a1*b4+a2*b5+a3*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for rotation_t {
    type Output = odd_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 32 muls / 24 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a3*b1-a1*b7-a2*b2;
          res.d[1]=a0*b1+a1*b2-a2*b7-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1-a3*b7;
          res.d[3]=a0*b3+a1*b4+a2*b5+a3*b6;
          res.d[4]=a0*b4+a3*b5-a1*b3-a2*b6;
          res.d[5]=a0*b5+a1*b6-a2*b3-a3*b4;
          res.d[6]=a0*b6+a2*b4-a1*b5-a3*b3;
          res.d[7]=a0*b7+a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for translation_t {
    type Output = odd_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a0*b0+a1*b1+a2*b2+b3;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for translation_t {
    type Output = even_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=a2*b1+b3-a1*b2;
          res.d[5]=a0*b2+b4-a2*b0;
          res.d[6]=a1*b0+b5-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for translation_t {
    type Output = trivector_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0-a0*b3;
          res.d[1]=b1-a1*b3;
          res.d[2]=b2-a2*b3;
          res.d[3]=b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for translation_t {
    type Output = quadvector_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for translation_t {
    type Output = horizon_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = horizon_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for translation_t {
    type Output = point_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for translation_t {
    type Output = point_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0-a0;
          res.d[1]=b1-a1;
          res.d[2]=b2-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for translation_t {
    type Output = direction_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for translation_t {
    type Output = even_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for translation_t {
    type Output = ibivector_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for translation_t {
    type Output = odd_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for translation_t {
    type Output = odd_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=1.0+a0*b0+a1*b1+a2*b2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for translation_t {
    type Output = even_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=a0*b0+a2*b2-a1*b3;
          res.d[5]=a0*b3+a1*b0-a2*b1;
          res.d[6]=a1*b1+a2*b0-a0*b2;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for translation_t {
    type Output = translation_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0+b0;
          res.d[1]=a1+b1;
          res.d[2]=a2+b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for translation_t {
    type Output = even_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=a0*b0+a2*b2+b4-a1*b3;
          res.d[5]=a0*b3+a1*b0+b5-a2*b1;
          res.d[6]=a1*b1+a2*b0+b6-a0*b2;
          res.d[7]=a0*b1+a1*b2+a2*b3+b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for translation_t {
    type Output = odd_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a0*b0+a1*b1+a2*b2+b3;
          res.d[4]=a2*b1+b4-a0*b7-a1*b2;
          res.d[5]=a0*b2+b5-a1*b7-a2*b0;
          res.d[6]=a1*b0+b6-a0*b1-a2*b7;
          res.d[7]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 28 muls / 20 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a0*b3+a4*b0+a5*b1+a6*b2;
          res.d[4]=a6*b1-a1*b3-a5*b2-a7*b0;
          res.d[5]=a4*b2-a2*b3-a6*b0-a7*b1;
          res.d[6]=a5*b0-a3*b3-a4*b1-a7*b2;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for even_t {
    type Output = even_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 36 muls / 29 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-a1*b0-a2*b1-a3*b2;
          res.d[1]=a0*b0+a3*b1-a2*b2;
          res.d[2]=a0*b1+a1*b2-a3*b0;
          res.d[3]=a0*b2+a2*b0-a1*b1;
          res.d[4]=a0*b3+a3*b4+a6*b1-a2*b5-a5*b2-a7*b0;
          res.d[5]=a0*b4+a1*b5+a4*b2-a3*b3-a6*b0-a7*b1;
          res.d[6]=a0*b5+a2*b3+a5*b0-a1*b4-a4*b1-a7*b2;
          res.d[7]=a1*b3+a2*b4+a3*b5+a4*b0+a5*b1+a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 20 muls / 15 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a1*b3;
          res.d[1]=-a2*b3;
          res.d[2]=-a3*b3;
          res.d[3]=a1*b0+a2*b1+a3*b2-a7*b3;
          res.d[4]=a0*b0+a3*b1-a2*b2-a4*b3;
          res.d[5]=a0*b1+a1*b2-a3*b0-a5*b3;
          res.d[6]=a0*b2+a2*b0-a1*b1-a6*b3;
          res.d[7]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for even_t {
    type Output = even_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a1*b0;
          res.d[5]=-a2*b0;
          res.d[6]=-a3*b0;
          res.d[7]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          res.d[4]=-a1;
          res.d[5]=-a2;
          res.d[6]=-a3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 7 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=-a1;
          res.d[1]=-a2;
          res.d[2]=-a3;
          res.d[3]=-a7;
          res.d[4]=-a4;
          res.d[5]=-a5;
          res.d[6]=-a6;
          res.d[7]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 15 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a1;
          res.d[1]=-a2;
          res.d[2]=-a3;
          res.d[3]=a1*b0+a2*b1+a3*b2-a7;
          res.d[4]=a0*b0+a3*b1-a2*b2-a4;
          res.d[5]=a0*b1+a1*b2-a3*b0-a5;
          res.d[6]=a0*b2+a2*b0-a1*b1-a6;
          res.d[7]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a1*b0+a2*b1+a3*b2;
          res.d[4]=a0*b0+a3*b1-a2*b2;
          res.d[5]=a0*b1+a1*b2-a3*b0;
          res.d[6]=a0*b2+a2*b0-a1*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for even_t {
    type Output = even_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 17 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a1*b0-a2*b1-a3*b2;
          res.d[1]=a0*b0+a3*b1-a2*b2;
          res.d[2]=a0*b1+a1*b2-a3*b0;
          res.d[3]=a0*b2+a2*b0-a1*b1;
          res.d[4]=a6*b1-a5*b2-a7*b0;
          res.d[5]=a4*b2-a6*b0-a7*b1;
          res.d[6]=a5*b0-a4*b1-a7*b2;
          res.d[7]=a4*b0+a5*b1+a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for even_t {
    type Output = even_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0+a3*b1-a2*b2;
          res.d[5]=a0*b1+a1*b2-a3*b0;
          res.d[6]=a0*b2+a2*b0-a1*b1;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 24 muls / 16 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a4*b0+a5*b1+a6*b2;
          res.d[4]=a6*b1-a5*b2-a7*b0;
          res.d[5]=a4*b2-a6*b0-a7*b1;
          res.d[6]=a5*b0-a4*b1-a7*b2;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 24 muls / 20 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a0+a4*b0+a5*b1+a6*b2;
          res.d[4]=a6*b1-a1-a5*b2-a7*b0;
          res.d[5]=a4*b2-a2-a6*b0-a7*b1;
          res.d[6]=a5*b0-a3-a4*b1-a7*b2;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for even_t {
    type Output = even_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 32 muls / 24 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a0*b1+a1*b0+a3*b2-a2*b3;
          res.d[2]=a0*b2+a1*b3+a2*b0-a3*b1;
          res.d[3]=a0*b3+a2*b1+a3*b0-a1*b2;
          res.d[4]=a4*b0+a6*b2-a5*b3-a7*b1;
          res.d[5]=a4*b3+a5*b0-a6*b1-a7*b2;
          res.d[6]=a5*b1+a6*b0-a4*b2-a7*b3;
          res.d[7]=a4*b1+a5*b2+a6*b3+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for even_t {
    type Output = even_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a0*b0+a3*b1+a4-a2*b2;
          res.d[5]=a0*b1+a1*b2+a5-a3*b0;
          res.d[6]=a0*b2+a2*b0+a6-a1*b1;
          res.d[7]=a1*b0+a2*b1+a3*b2+a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for even_t {
    type Output = even_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 48 muls / 40 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a0*b1+a1*b0+a3*b2-a2*b3;
          res.d[2]=a0*b2+a1*b3+a2*b0-a3*b1;
          res.d[3]=a0*b3+a2*b1+a3*b0-a1*b2;
          res.d[4]=a0*b4+a3*b5+a4*b0+a6*b2-a1*b7-a2*b6-a5*b3-a7*b1;
          res.d[5]=a0*b5+a1*b6+a4*b3+a5*b0-a2*b7-a3*b4-a6*b1-a7*b2;
          res.d[6]=a0*b6+a2*b4+a5*b1+a6*b0-a1*b5-a3*b7-a4*b2-a7*b3;
          res.d[7]=a0*b7+a1*b4+a2*b5+a3*b6+a4*b1+a5*b2+a6*b3+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<odd_t> for even_t {
    type Output = odd_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 48 muls / 40 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a3*b1-a1*b7-a2*b2;
          res.d[1]=a0*b1+a1*b2-a2*b7-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1-a3*b7;
          res.d[3]=a0*b3+a1*b4+a2*b5+a3*b6+a4*b0+a5*b1+a6*b2-a7*b7;
          res.d[4]=a0*b4+a3*b5+a6*b1-a1*b3-a2*b6-a4*b7-a5*b2-a7*b0;
          res.d[5]=a0*b5+a1*b6+a4*b2-a2*b3-a3*b4-a5*b7-a6*b0-a7*b1;
          res.d[6]=a0*b6+a2*b4+a5*b0-a1*b5-a3*b3-a4*b1-a6*b7-a7*b2;
          res.d[7]=a0*b7+a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<vector_t> for odd_t {
    type Output = even_t;
    fn mul(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 28 muls / 21 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2+a7*b0-a2*b1;
          res.d[2]=a2*b0+a7*b1-a0*b2;
          res.d[3]=a0*b1+a7*b2-a1*b0;
          res.d[4]=a3*b0+a5*b2-a0*b3-a6*b1;
          res.d[5]=a3*b1+a6*b0-a1*b3-a4*b2;
          res.d[6]=a3*b2+a4*b1-a2*b3-a5*b0;
          res.d[7]=-a4*b0-a5*b1-a6*b2-a7*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<bivector_t> for odd_t {
    type Output = odd_t;
    fn mul(self, rhs: bivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 36 muls / 28 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2-a7*b0;
          res.d[1]=a0*b2-a2*b0-a7*b1;
          res.d[2]=a1*b0-a0*b1-a7*b2;
          res.d[3]=a4*b0+a5*b1+a6*b2-a0*b3-a1*b4-a2*b5;
          res.d[4]=a1*b5+a6*b1+a7*b3-a2*b4-a3*b0-a5*b2;
          res.d[5]=a2*b3+a4*b2+a7*b4-a0*b5-a3*b1-a6*b0;
          res.d[6]=a0*b4+a5*b0+a7*b5-a1*b3-a3*b2-a4*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<trivector_t> for odd_t {
    type Output = even_t;
    fn mul(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 20 muls / 13 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a7*b3;
          res.d[1]=a0*b3;
          res.d[2]=a1*b3;
          res.d[3]=a2*b3;
          res.d[4]=a2*b1+a4*b3-a1*b2-a7*b0;
          res.d[5]=a0*b2+a5*b3-a2*b0-a7*b1;
          res.d[6]=a1*b0+a6*b3-a0*b1-a7*b2;
          res.d[7]=a0*b0+a1*b1+a2*b2+a3*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<quadvector_t> for odd_t {
    type Output = odd_t;
    fn mul(self, rhs: quadvector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 4 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
        let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a7*b0;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<horizon_t> for odd_t {
    type Output = even_t;
    fn mul(self, rhs: horizon_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a0;
          res.d[5]=-a1;
          res.d[6]=-a2;
          res.d[7]=-a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<origin_t> for odd_t {
    type Output = even_t;
    fn mul(self, rhs: origin_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 1 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=-a7;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a4;
          res.d[5]=a5;
          res.d[6]=a6;
          res.d[7]=a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<point_t> for odd_t {
    type Output = even_t;
    fn mul(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 13 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a7;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a2*b1+a4-a1*b2-a7*b0;
          res.d[5]=a0*b2+a5-a2*b0-a7*b1;
          res.d[6]=a1*b0+a6-a0*b1-a7*b2;
          res.d[7]=a0*b0+a1*b1+a2*b2+a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<direction_t> for odd_t {
    type Output = even_t;
    fn mul(self, rhs: direction_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2-a7*b0;
          res.d[5]=a0*b2-a2*b0-a7*b1;
          res.d[6]=a1*b0-a0*b1-a7*b2;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ebivector_t> for odd_t {
    type Output = odd_t;
    fn mul(self, rhs: ebivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 24 muls / 16 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2-a7*b0;
          res.d[1]=a0*b2-a2*b0-a7*b1;
          res.d[2]=a1*b0-a0*b1-a7*b2;
          res.d[3]=a4*b0+a5*b1+a6*b2;
          res.d[4]=a6*b1-a3*b0-a5*b2;
          res.d[5]=a4*b2-a3*b1-a6*b0;
          res.d[6]=a5*b0-a3*b2-a4*b1;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<ibivector_t> for odd_t {
    type Output = odd_t;
    fn mul(self, rhs: ibivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          res.d[4]=a1*b2+a7*b0-a2*b1;
          res.d[5]=a2*b0+a7*b1-a0*b2;
          res.d[6]=a0*b1+a7*b2-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<evector_t> for odd_t {
    type Output = even_t;
    fn mul(self, rhs: evector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 17 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2+a7*b0-a2*b1;
          res.d[2]=a2*b0+a7*b1-a0*b2;
          res.d[3]=a0*b1+a7*b2-a1*b0;
          res.d[4]=a3*b0+a5*b2-a6*b1;
          res.d[5]=a3*b1+a6*b0-a4*b2;
          res.d[6]=a3*b2+a4*b1-a5*b0;
          res.d[7]=-a4*b0-a5*b1-a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<dpoint_t> for odd_t {
    type Output = even_t;
    fn mul(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 21 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a1*b2+a7*b0-a2*b1;
          res.d[2]=a2*b0+a7*b1-a0*b2;
          res.d[3]=a0*b1+a7*b2-a1*b0;
          res.d[4]=a3*b0+a5*b2-a0-a6*b1;
          res.d[5]=a3*b1+a6*b0-a1-a4*b2;
          res.d[6]=a3*b2+a4*b1-a2-a5*b0;
          res.d[7]=-a4*b0-a5*b1-a6*b2-a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<rotation_t> for odd_t {
    type Output = odd_t;
    fn mul(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 32 muls / 24 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a2*b2-a1*b3-a7*b1;
          res.d[1]=a0*b3+a1*b0-a2*b1-a7*b2;
          res.d[2]=a1*b1+a2*b0-a0*b2-a7*b3;
          res.d[3]=a3*b0+a4*b1+a5*b2+a6*b3;
          res.d[4]=a4*b0+a6*b2-a3*b1-a5*b3;
          res.d[5]=a4*b3+a5*b0-a3*b2-a6*b1;
          res.d[6]=a5*b1+a6*b0-a3*b3-a4*b2;
          res.d[7]=a0*b1+a1*b2+a2*b3+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<translation_t> for odd_t {
    type Output = odd_t;
    fn mul(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3-a0*b0-a1*b1-a2*b2;
          res.d[4]=a1*b2+a4+a7*b0-a2*b1;
          res.d[5]=a2*b0+a5+a7*b1-a0*b2;
          res.d[6]=a0*b1+a6+a7*b2-a1*b0;
          res.d[7]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul<even_t> for odd_t {
    type Output = odd_t;
    fn mul(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 48 muls / 40 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a2*b2-a1*b3-a7*b1;
          res.d[1]=a0*b3+a1*b0-a2*b1-a7*b2;
          res.d[2]=a1*b1+a2*b0-a0*b2-a7*b3;
          res.d[3]=a3*b0+a4*b1+a5*b2+a6*b3+a7*b7-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7+a1*b6+a4*b0+a6*b2+a7*b4-a2*b5-a3*b1-a5*b3;
          res.d[5]=a1*b7+a2*b4+a4*b3+a5*b0+a7*b5-a0*b6-a3*b2-a6*b1;
          res.d[6]=a0*b5+a2*b7+a5*b1+a6*b0+a7*b6-a1*b4-a3*b3-a4*b2;
          res.d[7]=a0*b1+a1*b2+a2*b3+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Mul for odd_t {
    type Output = even_t;
    fn mul(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 48 muls / 40 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a1*b1+a2*b2-a7*b7;
          res.d[1]=a0*b7+a1*b2+a7*b0-a2*b1;
          res.d[2]=a1*b7+a2*b0+a7*b1-a0*b2;
          res.d[3]=a0*b1+a2*b7+a7*b2-a1*b0;
          res.d[4]=a2*b5+a3*b0+a4*b7+a5*b2-a0*b3-a1*b6-a6*b1-a7*b4;
          res.d[5]=a0*b6+a3*b1+a5*b7+a6*b0-a1*b3-a2*b4-a4*b2-a7*b5;
          res.d[6]=a1*b4+a3*b2+a4*b1+a6*b7-a0*b5-a2*b3-a5*b0-a7*b6;
          res.d[7]=a0*b4+a1*b5+a2*b6+a3*b7-a4*b0-a5*b1-a6*b2-a7*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for vector_t {
    type Output = vector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for bivector_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for trivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for quadvector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // rhs
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
          let b0=self.d[0];
          res.d[0]=rhs*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for horizon_t {
    type Output = vector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for origin_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for point_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for direction_t {
    type Output = direction_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for ebivector_t {
    type Output = ebivector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for ibivector_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for evector_t {
    type Output = evector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for dpoint_t {
    type Output = vector_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for rotation_t {
    type Output = rotation_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for translation_t {
    type Output = even_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=rhs*b0;
          res.d[5]=rhs*b1;
          res.d[6]=rhs*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for even_t {
    type Output = even_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 8 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
        let b6=self.d[6];
        let b7=self.d[7];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          res.d[6]=rhs*b6;
          res.d[7]=rhs*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<scalar_t> for odd_t {
    type Output = odd_t;
    fn bitxor(self, rhs: scalar_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 8 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
        let b6=self.d[6];
        let b7=self.d[7];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          res.d[6]=rhs*b6;
          res.d[7]=rhs*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for vector_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 12 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=a3*b0-a0*b3;
          res.d[4]=a3*b1-a1*b3;
          res.d[5]=a3*b2-a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for vector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a1*b5-a2*b4-a3*b0;
          res.d[1]=a2*b3-a0*b5-a3*b1;
          res.d[2]=a0*b4-a1*b3-a3*b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for vector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a1*b1+a2*b2+a3*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for vector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for vector_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for vector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let a3=self.d[3];
          res.d[0]=a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for vector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2+a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for vector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for vector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a3*b0;
          res.d[1]=-a3*b1;
          res.d[2]=-a3*b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for vector_t {
    type Output = direction_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for vector_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=a3*b0;
          res.d[4]=a3*b1;
          res.d[5]=a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for vector_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=a3*b0-a0;
          res.d[4]=a3*b1-a1;
          res.d[5]=a3*b2-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for vector_t {
    type Output = odd_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 10 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          res.d[4]=-a3*b1;
          res.d[5]=-a3*b2;
          res.d[6]=-a3*b3;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for vector_t {
    type Output = odd_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for vector_t {
    type Output = odd_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          res.d[4]=a1*b6-a2*b5-a3*b1;
          res.d[5]=a2*b4-a0*b6-a3*b2;
          res.d[6]=a0*b5-a1*b4-a3*b3;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for vector_t {
    type Output = even_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 16 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=a3*b0-a0*b3;
          res.d[5]=a3*b1-a1*b3;
          res.d[6]=a3*b2-a2*b3;
          res.d[7]=a0*b4+a1*b5+a2*b6+a3*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for bivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a5*b1-a0*b3-a4*b2;
          res.d[1]=a3*b2-a1*b3-a5*b0;
          res.d[2]=a4*b0-a2*b3-a3*b1;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for bivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a0*b3+a1*b4+a2*b5+a3*b0+a4*b1+a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for bivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for bivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for bivector_t {
    type Output = direction_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for bivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for bivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for bivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for bivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0+a4*b1+a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for bivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for bivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a5*b1-a4*b2;
          res.d[1]=a3*b2-a5*b0;
          res.d[2]=a4*b0-a3*b1;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for bivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a5*b1-a0-a4*b2;
          res.d[1]=a3*b2-a1-a5*b0;
          res.d[2]=a4*b0-a2-a3*b1;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for bivector_t {
    type Output = even_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=a0*b0;
          res.d[2]=a1*b0;
          res.d[3]=a2*b0;
          res.d[4]=a3*b0;
          res.d[5]=a4*b0;
          res.d[6]=a5*b0;
          res.d[7]=a3*b1+a4*b2+a5*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for bivector_t {
    type Output = even_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a3;
          res.d[5]=a4;
          res.d[6]=a5;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for bivector_t {
    type Output = even_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=0.0;
          res.d[1]=a0*b0;
          res.d[2]=a1*b0;
          res.d[3]=a2*b0;
          res.d[4]=a3*b0;
          res.d[5]=a4*b0;
          res.d[6]=a5*b0;
          res.d[7]=a0*b4+a1*b5+a2*b6+a3*b1+a4*b2+a5*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for bivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a5*b1-a0*b3-a4*b2;
          res.d[1]=a3*b2-a1*b3-a5*b0;
          res.d[2]=a4*b0-a2*b3-a3*b1;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for trivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₁₂₃
          // 4 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b0-a1*b1-a2*b2-a3*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for trivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for trivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for trivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for trivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₀
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          let a3=self.d[3];
          res.d[0]=-a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for trivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for trivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for trivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for trivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for trivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for trivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for trivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₁₂₃
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2-a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for trivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for trivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for trivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for trivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₁₂₃
          // 4 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b0-a1*b1-a2*b2-a3*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for quadvector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for quadvector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for quadvector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for quadvector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for horizon_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for horizon_t {
    type Output = direction_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for horizon_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let b3=rhs.d[3];
          res.d[0]=b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for horizon_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for horizon_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        
          // 1 e₀
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for horizon_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₀
          // 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for horizon_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for horizon_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for horizon_t {
    type Output = direction_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for horizon_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for horizon_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for horizon_t {
    type Output = odd_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          res.d[4]=-b1;
          res.d[5]=-b2;
          res.d[6]=-b3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for horizon_t {
    type Output = horizon_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = horizon_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for horizon_t {
    type Output = odd_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          res.d[4]=-b1;
          res.d[5]=-b2;
          res.d[6]=-b3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for horizon_t {
    type Output = even_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=b0;
          res.d[5]=b1;
          res.d[6]=b2;
          res.d[7]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for origin_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          let b3=rhs.d[3];
          res.d[0]=-b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for origin_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₁₂₃
          // 1 e₀
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // 1 e₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for origin_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for origin_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for origin_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for origin_t {
    type Output = origin_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = origin_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for origin_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for origin_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          let b3=rhs.d[3];
          res.d[0]=-b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for point_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₁₂₃
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b0-a1*b1-a2*b2-b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for point_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for point_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for point_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for point_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₀
          // -> r0 e₀₁₂₃
          // 0 muls / 1 adds
          res.d[0]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for point_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for point_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for point_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for point_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for point_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for point_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for point_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₁₂₃
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-1.0-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for point_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for point_t {
    type Output = point_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for point_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for point_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b0-a1*b1-a2*b2-b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for direction_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for direction_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for direction_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for direction_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for direction_t {
    type Output = direction_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for direction_t {
    type Output = direction_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for direction_t {
    type Output = direction_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for direction_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for ebivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b3;
          res.d[1]=-a1*b3;
          res.d[2]=-a2*b3;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for ebivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a0*b3+a1*b4+a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for ebivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for ebivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for ebivector_t {
    type Output = direction_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for ebivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for ebivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for ebivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for ebivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for ebivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for ebivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for ebivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for ebivector_t {
    type Output = ebivector_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for ebivector_t {
    type Output = even_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for ebivector_t {
    type Output = even_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=0.0;
          res.d[1]=a0*b0;
          res.d[2]=a1*b0;
          res.d[3]=a2*b0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0*b4+a1*b5+a2*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for ebivector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b3;
          res.d[1]=-a1*b3;
          res.d[2]=-a2*b3;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for ibivector_t {
    type Output = direction_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for ibivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for ibivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for ibivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for ibivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for ibivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for ibivector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for ibivector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for ibivector_t {
    type Output = direction_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for ibivector_t {
    type Output = direction_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for ibivector_t {
    type Output = even_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for ibivector_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for ibivector_t {
    type Output = even_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for ibivector_t {
    type Output = direction_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for evector_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=-a0*b3;
          res.d[4]=-a1*b3;
          res.d[5]=-a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for evector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a1*b5-a2*b4;
          res.d[1]=a2*b3-a0*b5;
          res.d[2]=a0*b4-a1*b3;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for evector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for evector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for evector_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for evector_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for evector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for evector_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for evector_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for evector_t {
    type Output = direction_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for evector_t {
    type Output = ebivector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for evector_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=-a0;
          res.d[4]=-a1;
          res.d[5]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for evector_t {
    type Output = odd_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for evector_t {
    type Output = odd_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=0.0;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for evector_t {
    type Output = odd_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=0.0;
          res.d[4]=a1*b6-a2*b5;
          res.d[5]=a2*b4-a0*b6;
          res.d[6]=a0*b5-a1*b4;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for evector_t {
    type Output = even_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=0.0;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=-a0*b3;
          res.d[5]=-a1*b3;
          res.d[6]=-a2*b3;
          res.d[7]=a0*b4+a1*b5+a2*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for dpoint_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=b0-a0*b3;
          res.d[4]=b1-a1*b3;
          res.d[5]=b2-a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for dpoint_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 9 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a1*b5-a2*b4-b0;
          res.d[1]=a2*b3-a0*b5-b1;
          res.d[2]=a0*b4-a1*b3-b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for dpoint_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a1*b1+a2*b2+b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for dpoint_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for dpoint_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for dpoint_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=1.0+a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for dpoint_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for dpoint_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for dpoint_t {
    type Output = direction_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for dpoint_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=b0;
          res.d[4]=b1;
          res.d[5]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for dpoint_t {
    type Output = bivector_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=b0-a0;
          res.d[4]=b1-a1;
          res.d[5]=b2-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for dpoint_t {
    type Output = odd_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=b0;
          res.d[4]=-b1;
          res.d[5]=-b2;
          res.d[6]=-b3;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for dpoint_t {
    type Output = odd_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=1.0;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for dpoint_t {
    type Output = odd_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=b0;
          res.d[4]=a1*b6-a2*b5-b1;
          res.d[5]=a2*b4-a0*b6-b2;
          res.d[6]=a0*b5-a1*b4-b3;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for dpoint_t {
    type Output = even_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=b0-a0*b3;
          res.d[5]=b1-a1*b3;
          res.d[6]=b2-a2*b3;
          res.d[7]=a0*b4+a1*b5+a2*b6+b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for rotation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 10 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          res.d[4]=-a1*b3;
          res.d[5]=-a2*b3;
          res.d[6]=-a3*b3;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for rotation_t {
    type Output = even_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=0.0;
          res.d[1]=a0*b0;
          res.d[2]=a0*b1;
          res.d[3]=a0*b2;
          res.d[4]=a0*b3;
          res.d[5]=a0*b4;
          res.d[6]=a0*b5;
          res.d[7]=a1*b3+a2*b4+a3*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for rotation_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for rotation_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for rotation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          res.d[4]=-a1;
          res.d[5]=-a2;
          res.d[6]=-a3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for rotation_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for rotation_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for rotation_t {
    type Output = direction_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for rotation_t {
    type Output = ebivector_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for rotation_t {
    type Output = even_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for rotation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for rotation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0;
          res.d[4]=-a1;
          res.d[5]=-a2;
          res.d[6]=-a3;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for rotation_t {
    type Output = rotation_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 7 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1+a1*b0;
          res.d[2]=a0*b2+a2*b0;
          res.d[3]=a0*b3+a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for rotation_t {
    type Output = even_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for rotation_t {
    type Output = even_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 14 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1+a1*b0;
          res.d[2]=a0*b2+a2*b0;
          res.d[3]=a0*b3+a3*b0;
          res.d[4]=a0*b4;
          res.d[5]=a0*b5;
          res.d[6]=a0*b6;
          res.d[7]=a0*b7+a1*b4+a2*b5+a3*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for rotation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 14 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          res.d[4]=a0*b4-a1*b3;
          res.d[5]=a0*b5-a2*b3;
          res.d[6]=a0*b6-a3*b3;
          res.d[7]=a0*b7+a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for translation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for translation_t {
    type Output = even_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=b3;
          res.d[5]=b4;
          res.d[6]=b5;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for translation_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for translation_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for translation_t {
    type Output = horizon_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = horizon_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for translation_t {
    type Output = origin_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        let mut res = origin_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for translation_t {
    type Output = point_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for translation_t {
    type Output = direction_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for translation_t {
    type Output = even_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for translation_t {
    type Output = ibivector_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for translation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=0.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for translation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=1.0;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for translation_t {
    type Output = even_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=a0*b1+a1*b2+a2*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for translation_t {
    type Output = translation_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0+b0;
          res.d[1]=a1+b1;
          res.d[2]=a2+b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for translation_t {
    type Output = even_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=a0*b0+b4;
          res.d[5]=a1*b0+b5;
          res.d[6]=a2*b0+b6;
          res.d[7]=a0*b1+a1*b2+a2*b3+b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for translation_t {
    type Output = odd_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=a2*b1+b4-a1*b2;
          res.d[5]=a0*b2+b5-a2*b0;
          res.d[6]=a1*b0+b6-a0*b1;
          res.d[7]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for even_t {
    type Output = odd_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          res.d[4]=a6*b1-a1*b3-a5*b2;
          res.d[5]=a4*b2-a2*b3-a6*b0;
          res.d[6]=a5*b0-a3*b3-a4*b1;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for even_t {
    type Output = even_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=0.0;
          res.d[1]=a0*b0;
          res.d[2]=a0*b1;
          res.d[3]=a0*b2;
          res.d[4]=a0*b3;
          res.d[5]=a0*b4;
          res.d[6]=a0*b5;
          res.d[7]=a1*b3+a2*b4+a3*b5+a4*b0+a5*b1+a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for even_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for even_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for even_t {
    type Output = odd_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          res.d[4]=-a1;
          res.d[5]=-a2;
          res.d[6]=-a3;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for even_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for even_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for even_t {
    type Output = direction_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for even_t {
    type Output = even_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a0*b0;
          res.d[2]=a0*b1;
          res.d[3]=a0*b2;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a4*b0+a5*b1+a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for even_t {
    type Output = even_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for even_t {
    type Output = odd_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=0.0;
          res.d[4]=a6*b1-a5*b2;
          res.d[5]=a4*b2-a6*b0;
          res.d[6]=a5*b0-a4*b1;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for even_t {
    type Output = odd_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0;
          res.d[4]=a6*b1-a1-a5*b2;
          res.d[5]=a4*b2-a2-a6*b0;
          res.d[6]=a5*b0-a3-a4*b1;
          res.d[7]=a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for even_t {
    type Output = even_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 14 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1+a1*b0;
          res.d[2]=a0*b2+a2*b0;
          res.d[3]=a0*b3+a3*b0;
          res.d[4]=a4*b0;
          res.d[5]=a5*b0;
          res.d[6]=a6*b0;
          res.d[7]=a4*b1+a5*b2+a6*b3+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for even_t {
    type Output = even_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a0*b0+a4;
          res.d[5]=a0*b1+a5;
          res.d[6]=a0*b2+a6;
          res.d[7]=a1*b0+a2*b1+a3*b2+a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for even_t {
    type Output = even_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 21 muls / 13 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1+a1*b0;
          res.d[2]=a0*b2+a2*b0;
          res.d[3]=a0*b3+a3*b0;
          res.d[4]=a0*b4+a4*b0;
          res.d[5]=a0*b5+a5*b0;
          res.d[6]=a0*b6+a6*b0;
          res.d[7]=a0*b7+a1*b4+a2*b5+a3*b6+a4*b1+a5*b2+a6*b3+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<odd_t> for even_t {
    type Output = odd_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 20 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          res.d[4]=a0*b4+a6*b1-a1*b3-a5*b2;
          res.d[5]=a0*b5+a4*b2-a2*b3-a6*b0;
          res.d[6]=a0*b6+a5*b0-a3*b3-a4*b1;
          res.d[7]=a0*b7+a1*b0+a2*b1+a3*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<vector_t> for odd_t {
    type Output = even_t;
    fn bitxor(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 16 muls / 10 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=a3*b0-a0*b3;
          res.d[5]=a3*b1-a1*b3;
          res.d[6]=a3*b2-a2*b3;
          res.d[7]=-a4*b0-a5*b1-a6*b2-a7*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<bivector_t> for odd_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: bivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a1*b5-a2*b4-a3*b0;
          res.d[1]=a2*b3-a0*b5-a3*b1;
          res.d[2]=a0*b4-a1*b3-a3*b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<trivector_t> for odd_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: trivector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a1*b1+a2*b2+a3*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<quadvector_t> for odd_t {
    type Output = scalar_t;
    fn bitxor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<horizon_t> for odd_t {
    type Output = even_t;
    fn bitxor(self, rhs: horizon_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a0;
          res.d[5]=-a1;
          res.d[6]=-a2;
          res.d[7]=-a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<origin_t> for odd_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: origin_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let a3=self.d[3];
          res.d[0]=a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<point_t> for odd_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: point_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2+a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<direction_t> for odd_t {
    type Output = quadvector_t;
    fn bitxor(self, rhs: direction_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁₂₃
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ebivector_t> for odd_t {
    type Output = trivector_t;
    fn bitxor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a3*b0;
          res.d[1]=-a3*b1;
          res.d[2]=-a3*b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<ibivector_t> for odd_t {
    type Output = direction_t;
    fn bitxor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<evector_t> for odd_t {
    type Output = even_t;
    fn bitxor(self, rhs: evector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=a3*b0;
          res.d[5]=a3*b1;
          res.d[6]=a3*b2;
          res.d[7]=-a4*b0-a5*b1-a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<dpoint_t> for odd_t {
    type Output = even_t;
    fn bitxor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 10 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=a3*b0-a0;
          res.d[5]=a3*b1-a1;
          res.d[6]=a3*b2-a2;
          res.d[7]=-a4*b0-a5*b1-a6*b2-a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<rotation_t> for odd_t {
    type Output = odd_t;
    fn bitxor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 14 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          res.d[4]=a4*b0-a3*b1;
          res.d[5]=a5*b0-a3*b2;
          res.d[6]=a6*b0-a3*b3;
          res.d[7]=a0*b1+a1*b2+a2*b3+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<translation_t> for odd_t {
    type Output = odd_t;
    fn bitxor(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a1*b2+a4-a2*b1;
          res.d[5]=a2*b0+a5-a0*b2;
          res.d[6]=a0*b1+a6-a1*b0;
          res.d[7]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor<even_t> for odd_t {
    type Output = odd_t;
    fn bitxor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 20 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          res.d[4]=a1*b6+a4*b0-a2*b5-a3*b1;
          res.d[5]=a2*b4+a5*b0-a0*b6-a3*b2;
          res.d[6]=a0*b5+a6*b0-a1*b4-a3*b3;
          res.d[7]=a0*b1+a1*b2+a2*b3+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitXor for odd_t {
    type Output = even_t;
    fn bitxor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 20 muls / 13 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=a1*b2-a2*b1;
          res.d[2]=a2*b0-a0*b2;
          res.d[3]=a0*b1-a1*b0;
          res.d[4]=a3*b0-a0*b3;
          res.d[5]=a3*b1-a1*b3;
          res.d[6]=a3*b2-a2*b3;
          res.d[7]=a0*b4+a1*b5+a2*b6+a3*b7-a4*b0-a5*b1-a6*b2-a7*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for vector_t {
    type Output = vector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for bivector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for trivector_t {
    type Output = trivector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for quadvector_t {
    type Output = quadvector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // rhs
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
          let b0=self.d[0];
          res.d[0]=rhs*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for horizon_t {
    type Output = vector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for origin_t {
    type Output = trivector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for point_t {
    type Output = trivector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for direction_t {
    type Output = direction_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for ebivector_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for ibivector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for evector_t {
    type Output = evector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for dpoint_t {
    type Output = vector_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for rotation_t {
    type Output = rotation_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 4 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for translation_t {
    type Output = even_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
          res.d[0]=rhs;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=rhs*b0;
          res.d[5]=rhs*b1;
          res.d[6]=rhs*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for even_t {
    type Output = even_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 8 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
        let b6=self.d[6];
        let b7=self.d[7];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          res.d[6]=rhs*b6;
          res.d[7]=rhs*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<scalar_t> for odd_t {
    type Output = odd_t;
    fn bitor(self, rhs: scalar_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 8 muls / 0 adds
        let b0=self.d[0];
        let b1=self.d[1];
        let b2=self.d[2];
        let b3=self.d[3];
        let b4=self.d[4];
        let b5=self.d[5];
        let b6=self.d[6];
        let b7=self.d[7];
          res.d[0]=rhs*b0;
          res.d[1]=rhs*b1;
          res.d[2]=rhs*b2;
          res.d[3]=rhs*b3;
          res.d[4]=rhs*b4;
          res.d[5]=rhs*b5;
          res.d[6]=rhs*b6;
          res.d[7]=rhs*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for vector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for vector_t {
    type Output = vector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for vector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b3;
          res.d[1]=a1*b3;
          res.d[2]=a2*b3;
          res.d[3]=a2*b1-a1*b2;
          res.d[4]=a0*b2-a2*b0;
          res.d[5]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for vector_t {
    type Output = direction_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for vector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for vector_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for vector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a2*b1-a1*b2;
          res.d[4]=a0*b2-a2*b0;
          res.d[5]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for vector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for vector_t {
    type Output = evector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for vector_t {
    type Output = vector_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for vector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for vector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for vector_t {
    type Output = vector_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 10 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for vector_t {
    type Output = vector_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for vector_t {
    type Output = odd_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=a3*b0-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7;
          res.d[5]=a1*b7;
          res.d[6]=a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for vector_t {
    type Output = even_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a0*b7;
          res.d[2]=a1*b7;
          res.d[3]=a2*b7;
          res.d[4]=a2*b5-a1*b6;
          res.d[5]=a0*b6-a2*b4;
          res.d[6]=a1*b4-a0*b5;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for bivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=a3*b0+a4*b1+a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for bivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for bivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b3;
          res.d[1]=-a1*b3;
          res.d[2]=-a2*b3;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for bivector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=-a0*b0;
          res.d[1]=-a1*b0;
          res.d[2]=-a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for bivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for bivector_t {
    type Output = evector_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for bivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for bivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for bivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for bivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for bivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=a3*b0+a4*b1+a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for bivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=a3*b0+a4*b1+a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for bivector_t {
    type Output = even_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b1-a1*b2-a2*b3;
          res.d[1]=a0*b0;
          res.d[2]=a1*b0;
          res.d[3]=a2*b0;
          res.d[4]=a3*b0;
          res.d[5]=a4*b0;
          res.d[6]=a5*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for bivector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a4;
          res.d[5]=a5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for bivector_t {
    type Output = even_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b7=rhs.d[7];
          res.d[0]=-a0*b1-a1*b2-a2*b3;
          res.d[1]=a0*b0;
          res.d[2]=a1*b0;
          res.d[3]=a2*b0;
          res.d[4]=a3*b0-a0*b7;
          res.d[5]=a4*b0-a1*b7;
          res.d[6]=a5*b0-a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for bivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 15 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a2*b1-a0*b7-a1*b2;
          res.d[1]=a0*b2-a1*b7-a2*b0;
          res.d[2]=a1*b0-a0*b1-a2*b7;
          res.d[3]=a0*b4+a1*b5+a2*b6+a3*b0+a4*b1+a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for trivector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0;
          res.d[1]=a3*b1;
          res.d[2]=a3*b2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for trivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a3*b0;
          res.d[1]=-a3*b1;
          res.d[2]=-a3*b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for trivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 1 muls / 1 adds
        let a3=self.d[3];
        let b3=rhs.d[3];
          return -a3*b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for trivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 1 muls / 0 adds
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for trivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for trivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          let a3=self.d[3];
          return -a3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for trivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          let a3=self.d[3];
          return -a3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for trivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for trivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a3*b0;
          res.d[1]=-a3*b1;
          res.d[2]=-a3*b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for trivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for trivector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0;
          res.d[1]=a3*b1;
          res.d[2]=a3*b2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for trivector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0;
          res.d[1]=a3*b1;
          res.d[2]=a3*b2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for trivector_t {
    type Output = odd_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 10 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a3*b1;
          res.d[1]=-a3*b2;
          res.d[2]=-a3*b3;
          res.d[3]=a0*b1+a1*b2+a2*b3;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for trivector_t {
    type Output = trivector_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for trivector_t {
    type Output = odd_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 11 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b7=rhs.d[7];
          res.d[0]=-a3*b1;
          res.d[1]=-a3*b2;
          res.d[2]=-a3*b3;
          res.d[3]=a0*b1+a1*b2+a2*b3+a3*b7;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for trivector_t {
    type Output = even_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 10 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=-a3*b7;
          res.d[1]=a3*b0;
          res.d[2]=a3*b1;
          res.d[3]=a3*b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for quadvector_t {
    type Output = direction_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for quadvector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for quadvector_t {
    type Output = vector_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 1 muls / 1 adds
        let a0=self.d[0];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for quadvector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for quadvector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for quadvector_t {
    type Output = vector_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for quadvector_t {
    type Output = vector_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for quadvector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for quadvector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for quadvector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for quadvector_t {
    type Output = direction_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for quadvector_t {
    type Output = direction_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0*b0;
          res.d[1]=-a0*b1;
          res.d[2]=-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for quadvector_t {
    type Output = even_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a0*b1;
          res.d[5]=-a0*b2;
          res.d[6]=-a0*b3;
          res.d[7]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for quadvector_t {
    type Output = quadvector_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for quadvector_t {
    type Output = even_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a0*b1;
          res.d[5]=-a0*b2;
          res.d[6]=-a0*b3;
          res.d[7]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for quadvector_t {
    type Output = odd_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 4 muls / 4 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b7;
          res.d[4]=-a0*b0;
          res.d[5]=-a0*b1;
          res.d[6]=-a0*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // 1 e₀
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        
          // 1 e₀
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for horizon_t {
    type Output = vector_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for horizon_t {
    type Output = horizon_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = horizon_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for horizon_t {
    type Output = vector_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for horizon_t {
    type Output = scalar_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for origin_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for origin_t {
    type Output = evector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for origin_t {
    type Output = scalar_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          let b3=rhs.d[3];
          return -b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for origin_t {
    type Output = vector_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for origin_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // 1 e₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for origin_t {
    type Output = scalar_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        
          // 1 e₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          return -1.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for origin_t {
    type Output = scalar_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          return -1.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for origin_t {
    type Output = scalar_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for origin_t {
    type Output = evector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for origin_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for origin_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for origin_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for origin_t {
    type Output = odd_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-b1;
          res.d[1]=-b2;
          res.d[2]=-b3;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for origin_t {
    type Output = origin_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = origin_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for origin_t {
    type Output = odd_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b7=rhs.d[7];
          res.d[0]=-b1;
          res.d[1]=-b2;
          res.d[2]=-b3;
          res.d[3]=b7;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for origin_t {
    type Output = rotation_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 1 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=-b7;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for point_t {
    type Output = bivector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for point_t {
    type Output = vector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for point_t {
    type Output = scalar_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          let b3=rhs.d[3];
          return -b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for point_t {
    type Output = vector_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for point_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for point_t {
    type Output = scalar_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          return -1.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for point_t {
    type Output = scalar_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 1 adds
          return -1.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for point_t {
    type Output = scalar_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for point_t {
    type Output = vector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-b0;
          res.d[1]=-b1;
          res.d[2]=-b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for point_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for point_t {
    type Output = bivector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for point_t {
    type Output = bivector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for point_t {
    type Output = odd_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-b1;
          res.d[1]=-b2;
          res.d[2]=-b3;
          res.d[3]=a0*b1+a1*b2+a2*b3;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for point_t {
    type Output = point_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for point_t {
    type Output = odd_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b7=rhs.d[7];
          res.d[0]=-b1;
          res.d[1]=-b2;
          res.d[2]=-b3;
          res.d[3]=a0*b1+a1*b2+a2*b3+b7;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for point_t {
    type Output = even_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b7=rhs.d[7];
          res.d[0]=-b7;
          res.d[1]=b0;
          res.d[2]=b1;
          res.d[3]=b2;
          res.d[4]=a1*b2-a2*b1;
          res.d[5]=a2*b0-a0*b2;
          res.d[6]=a0*b1-a1*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for direction_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for direction_t {
    type Output = vector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for direction_t {
    type Output = scalar_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for direction_t {
    type Output = scalar_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for direction_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for direction_t {
    type Output = scalar_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for direction_t {
    type Output = scalar_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for direction_t {
    type Output = scalar_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for direction_t {
    type Output = vector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for direction_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for direction_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for direction_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for direction_t {
    type Output = odd_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b1+a1*b2+a2*b3;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for direction_t {
    type Output = direction_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for direction_t {
    type Output = odd_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b1+a1*b2+a2*b3;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for direction_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for ebivector_t {
    type Output = evector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for ebivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for ebivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b3;
          res.d[1]=-a1*b3;
          res.d[2]=-a2*b3;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for ebivector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=-a0*b0;
          res.d[1]=-a1*b0;
          res.d[2]=-a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for ebivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for ebivector_t {
    type Output = evector_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for ebivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for ebivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for ebivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for ebivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for ebivector_t {
    type Output = evector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for ebivector_t {
    type Output = evector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for ebivector_t {
    type Output = rotation_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b1-a1*b2-a2*b3;
          res.d[1]=a0*b0;
          res.d[2]=a1*b0;
          res.d[3]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for ebivector_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for ebivector_t {
    type Output = even_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b7=rhs.d[7];
          res.d[0]=-a0*b1-a1*b2-a2*b3;
          res.d[1]=a0*b0;
          res.d[2]=a1*b0;
          res.d[3]=a2*b0;
          res.d[4]=-a0*b7;
          res.d[5]=-a1*b7;
          res.d[6]=-a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for ebivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a2*b1-a0*b7-a1*b2;
          res.d[1]=a0*b2-a1*b7-a2*b0;
          res.d[2]=a1*b0-a0*b1-a2*b7;
          res.d[3]=a0*b4+a1*b5+a2*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for ibivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for ibivector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for ibivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for ibivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for ibivector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for ibivector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for ibivector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for ibivector_t {
    type Output = vector_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for evector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for evector_t {
    type Output = vector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for evector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b3;
          res.d[1]=a1*b3;
          res.d[2]=a2*b3;
          res.d[3]=a2*b1-a1*b2;
          res.d[4]=a0*b2-a2*b0;
          res.d[5]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for evector_t {
    type Output = direction_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for evector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for evector_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for evector_t {
    type Output = bivector_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a2*b1-a1*b2;
          res.d[4]=a0*b2-a2*b0;
          res.d[5]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for evector_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for evector_t {
    type Output = evector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for evector_t {
    type Output = vector_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for evector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for evector_t {
    type Output = scalar_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for evector_t {
    type Output = evector_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for evector_t {
    type Output = vector_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for evector_t {
    type Output = odd_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 15 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7;
          res.d[5]=a1*b7;
          res.d[6]=a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for evector_t {
    type Output = even_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a0*b7;
          res.d[2]=a1*b7;
          res.d[3]=a2*b7;
          res.d[4]=a2*b5-a1*b6;
          res.d[5]=a0*b6-a2*b4;
          res.d[6]=a1*b4-a0*b5;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for dpoint_t {
    type Output = vector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for dpoint_t {
    type Output = bivector_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b3;
          res.d[1]=a1*b3;
          res.d[2]=a2*b3;
          res.d[3]=a2*b1-a1*b2;
          res.d[4]=a0*b2-a2*b0;
          res.d[5]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for dpoint_t {
    type Output = direction_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for dpoint_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for dpoint_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for dpoint_t {
    type Output = bivector_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a2*b1-a1*b2;
          res.d[4]=a0*b2-a2*b0;
          res.d[5]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for dpoint_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for dpoint_t {
    type Output = evector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for dpoint_t {
    type Output = vector_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for dpoint_t {
    type Output = scalar_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for dpoint_t {
    type Output = vector_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for dpoint_t {
    type Output = vector_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=1.0-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for dpoint_t {
    type Output = odd_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 15 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a2*b2-a1*b3;
          res.d[1]=a0*b3+a1*b0-a2*b1;
          res.d[2]=a1*b1+a2*b0-a0*b2;
          res.d[3]=b0-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7;
          res.d[5]=a1*b7;
          res.d[6]=a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for dpoint_t {
    type Output = even_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a0*b7;
          res.d[2]=a1*b7;
          res.d[3]=a2*b7;
          res.d[4]=a2*b5-a1*b6;
          res.d[5]=a0*b6-a2*b4;
          res.d[6]=a1*b4-a0*b5;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for rotation_t {
    type Output = vector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 10 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for rotation_t {
    type Output = even_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-a1*b0-a2*b1-a3*b2;
          res.d[1]=a0*b0;
          res.d[2]=a0*b1;
          res.d[3]=a0*b2;
          res.d[4]=a0*b3;
          res.d[5]=a0*b4;
          res.d[6]=a0*b5;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for rotation_t {
    type Output = odd_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 10 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a1*b3;
          res.d[1]=-a2*b3;
          res.d[2]=-a3*b3;
          res.d[3]=a1*b0+a2*b1+a3*b2;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for rotation_t {
    type Output = even_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a1*b0;
          res.d[5]=-a2*b0;
          res.d[6]=-a3*b0;
          res.d[7]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for rotation_t {
    type Output = vector_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for rotation_t {
    type Output = odd_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=-a1;
          res.d[1]=-a2;
          res.d[2]=-a3;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for rotation_t {
    type Output = odd_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a1;
          res.d[1]=-a2;
          res.d[2]=-a3;
          res.d[3]=a1*b0+a2*b1+a3*b2;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for rotation_t {
    type Output = odd_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a1*b0+a2*b1+a3*b2;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for rotation_t {
    type Output = rotation_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a1*b0-a2*b1-a3*b2;
          res.d[1]=a0*b0;
          res.d[2]=a0*b1;
          res.d[3]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for rotation_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for rotation_t {
    type Output = evector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for rotation_t {
    type Output = vector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for rotation_t {
    type Output = rotation_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 10 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a0*b1+a1*b0;
          res.d[2]=a0*b2+a2*b0;
          res.d[3]=a0*b3+a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for rotation_t {
    type Output = even_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for rotation_t {
    type Output = even_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 17 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a0*b1+a1*b0;
          res.d[2]=a0*b2+a2*b0;
          res.d[3]=a0*b3+a3*b0;
          res.d[4]=a0*b4-a1*b7;
          res.d[5]=a0*b5-a2*b7;
          res.d[6]=a0*b6-a3*b7;
          res.d[7]=a0*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for rotation_t {
    type Output = odd_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 20 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a3*b1-a1*b7-a2*b2;
          res.d[1]=a0*b1+a1*b2-a2*b7-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1-a3*b7;
          res.d[3]=a0*b3+a1*b4+a2*b5+a3*b6;
          res.d[4]=a0*b4;
          res.d[5]=a0*b5;
          res.d[6]=a0*b6;
          res.d[7]=a0*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for translation_t {
    type Output = vector_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a0*b0+a1*b1+a2*b2+b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for translation_t {
    type Output = bivector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=b4;
          res.d[5]=b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for translation_t {
    type Output = trivector_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for translation_t {
    type Output = quadvector_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for translation_t {
    type Output = horizon_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        let mut res = horizon_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for translation_t {
    type Output = origin_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = origin_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for translation_t {
    type Output = point_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for translation_t {
    type Output = direction_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for translation_t {
    type Output = ebivector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for translation_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for translation_t {
    type Output = vector_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for translation_t {
    type Output = vector_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=1.0+a0*b0+a1*b1+a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for translation_t {
    type Output = even_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for translation_t {
    type Output = translation_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0+b0;
          res.d[1]=a1+b1;
          res.d[2]=a2+b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for translation_t {
    type Output = even_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=a0*b0+b4;
          res.d[5]=a1*b0+b5;
          res.d[6]=a2*b0+b6;
          res.d[7]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for translation_t {
    type Output = odd_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a0*b0+a1*b1+a2*b2+b3;
          res.d[4]=b4;
          res.d[5]=b5;
          res.d[6]=b6;
          res.d[7]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for even_t {
    type Output = odd_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a0*b3+a4*b0+a5*b1+a6*b2;
          res.d[4]=-a7*b0;
          res.d[5]=-a7*b1;
          res.d[6]=-a7*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for even_t {
    type Output = even_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=-a1*b0-a2*b1-a3*b2;
          res.d[1]=a0*b0;
          res.d[2]=a0*b1;
          res.d[3]=a0*b2;
          res.d[4]=a0*b3-a7*b0;
          res.d[5]=a0*b4-a7*b1;
          res.d[6]=a0*b5-a7*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for even_t {
    type Output = odd_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 11 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a1*b3;
          res.d[1]=-a2*b3;
          res.d[2]=-a3*b3;
          res.d[3]=a1*b0+a2*b1+a3*b2-a7*b3;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for even_t {
    type Output = even_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 4 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=-a1*b0;
          res.d[5]=-a2*b0;
          res.d[6]=-a3*b0;
          res.d[7]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for even_t {
    type Output = vector_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for even_t {
    type Output = odd_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a7=self.d[7];
          res.d[0]=-a1;
          res.d[1]=-a2;
          res.d[2]=-a3;
          res.d[3]=-a7;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for even_t {
    type Output = odd_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a1;
          res.d[1]=-a2;
          res.d[2]=-a3;
          res.d[3]=a1*b0+a2*b1+a3*b2-a7;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for even_t {
    type Output = odd_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a1*b0+a2*b1+a3*b2;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for even_t {
    type Output = even_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a1*b0-a2*b1-a3*b2;
          res.d[1]=a0*b0;
          res.d[2]=a0*b1;
          res.d[3]=a0*b2;
          res.d[4]=-a7*b0;
          res.d[5]=-a7*b1;
          res.d[6]=-a7*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for even_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for even_t {
    type Output = odd_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 15 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a4*b0+a5*b1+a6*b2;
          res.d[4]=-a7*b0;
          res.d[5]=-a7*b1;
          res.d[6]=-a7*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for even_t {
    type Output = odd_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 15 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a3*b1-a2*b2;
          res.d[1]=a0*b1+a1*b2-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1;
          res.d[3]=a0+a4*b0+a5*b1+a6*b2;
          res.d[4]=-a7*b0;
          res.d[5]=-a7*b1;
          res.d[6]=-a7*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for even_t {
    type Output = even_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 17 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a0*b1+a1*b0;
          res.d[2]=a0*b2+a2*b0;
          res.d[3]=a0*b3+a3*b0;
          res.d[4]=a4*b0-a7*b1;
          res.d[5]=a5*b0-a7*b2;
          res.d[6]=a6*b0-a7*b3;
          res.d[7]=a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for even_t {
    type Output = even_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          res.d[4]=a0*b0+a4;
          res.d[5]=a0*b1+a5;
          res.d[6]=a0*b2+a6;
          res.d[7]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for even_t {
    type Output = even_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 24 muls / 16 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a0*b1+a1*b0;
          res.d[2]=a0*b2+a2*b0;
          res.d[3]=a0*b3+a3*b0;
          res.d[4]=a0*b4+a4*b0-a1*b7-a7*b1;
          res.d[5]=a0*b5+a5*b0-a2*b7-a7*b2;
          res.d[6]=a0*b6+a6*b0-a3*b7-a7*b3;
          res.d[7]=a0*b7+a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<odd_t> for even_t {
    type Output = odd_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 27 muls / 19 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a3*b1-a1*b7-a2*b2;
          res.d[1]=a0*b1+a1*b2-a2*b7-a3*b0;
          res.d[2]=a0*b2+a2*b0-a1*b1-a3*b7;
          res.d[3]=a0*b3+a1*b4+a2*b5+a3*b6+a4*b0+a5*b1+a6*b2-a7*b7;
          res.d[4]=a0*b4-a7*b0;
          res.d[5]=a0*b5-a7*b1;
          res.d[6]=a0*b6-a7*b2;
          res.d[7]=a0*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<vector_t> for odd_t {
    type Output = even_t;
    fn bitor(self, rhs: vector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a7*b0;
          res.d[2]=a7*b1;
          res.d[3]=a7*b2;
          res.d[4]=a5*b2-a6*b1;
          res.d[5]=a6*b0-a4*b2;
          res.d[6]=a4*b1-a5*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<bivector_t> for odd_t {
    type Output = vector_t;
    fn bitor(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 15 muls / 11 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2-a7*b0;
          res.d[1]=a0*b2-a2*b0-a7*b1;
          res.d[2]=a1*b0-a0*b1-a7*b2;
          res.d[3]=a4*b0+a5*b1+a6*b2-a0*b3-a1*b4-a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<trivector_t> for odd_t {
    type Output = even_t;
    fn bitor(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 10 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a7*b3;
          res.d[1]=a0*b3;
          res.d[2]=a1*b3;
          res.d[3]=a2*b3;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<quadvector_t> for odd_t {
    type Output = odd_t;
    fn bitor(self, rhs: quadvector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 4 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
        let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a7*b0;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<horizon_t> for odd_t {
    type Output = scalar_t;
    fn bitor(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<origin_t> for odd_t {
    type Output = rotation_t;
    fn bitor(self, rhs: origin_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 1 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
          res.d[0]=-a7;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<point_t> for odd_t {
    type Output = even_t;
    fn bitor(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a7;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=a2*b1-a1*b2;
          res.d[5]=a0*b2-a2*b0;
          res.d[6]=a1*b0-a0*b1;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<direction_t> for odd_t {
    type Output = ibivector_t;
    fn bitor(self, rhs: direction_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ebivector_t> for odd_t {
    type Output = vector_t;
    fn bitor(self, rhs: ebivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2-a7*b0;
          res.d[1]=a0*b2-a2*b0-a7*b1;
          res.d[2]=a1*b0-a0*b1-a7*b2;
          res.d[3]=a4*b0+a5*b1+a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<ibivector_t> for odd_t {
    type Output = vector_t;
    fn bitor(self, rhs: ibivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<evector_t> for odd_t {
    type Output = even_t;
    fn bitor(self, rhs: evector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a7*b0;
          res.d[2]=a7*b1;
          res.d[3]=a7*b2;
          res.d[4]=a5*b2-a6*b1;
          res.d[5]=a6*b0-a4*b2;
          res.d[6]=a4*b1-a5*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<dpoint_t> for odd_t {
    type Output = even_t;
    fn bitor(self, rhs: dpoint_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a7*b0;
          res.d[2]=a7*b1;
          res.d[3]=a7*b2;
          res.d[4]=a5*b2-a6*b1;
          res.d[5]=a6*b0-a4*b2;
          res.d[6]=a4*b1-a5*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<rotation_t> for odd_t {
    type Output = odd_t;
    fn bitor(self, rhs: rotation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 20 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a2*b2-a1*b3-a7*b1;
          res.d[1]=a0*b3+a1*b0-a2*b1-a7*b2;
          res.d[2]=a1*b1+a2*b0-a0*b2-a7*b3;
          res.d[3]=a3*b0+a4*b1+a5*b2+a6*b3;
          res.d[4]=a4*b0;
          res.d[5]=a5*b0;
          res.d[6]=a6*b0;
          res.d[7]=a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<translation_t> for odd_t {
    type Output = odd_t;
    fn bitor(self, rhs: translation_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3-a0*b0-a1*b1-a2*b2;
          res.d[4]=a4;
          res.d[5]=a5;
          res.d[6]=a6;
          res.d[7]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr<even_t> for odd_t {
    type Output = odd_t;
    fn bitor(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 27 muls / 19 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a2*b2-a1*b3-a7*b1;
          res.d[1]=a0*b3+a1*b0-a2*b1-a7*b2;
          res.d[2]=a1*b1+a2*b0-a0*b2-a7*b3;
          res.d[3]=a3*b0+a4*b1+a5*b2+a6*b3+a7*b7-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7+a4*b0;
          res.d[5]=a1*b7+a5*b0;
          res.d[6]=a2*b7+a6*b0;
          res.d[7]=a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitOr for odd_t {
    type Output = even_t;
    fn bitor(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 22 muls / 15 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0+a1*b1+a2*b2-a7*b7;
          res.d[1]=a0*b7+a7*b0;
          res.d[2]=a1*b7+a7*b1;
          res.d[3]=a2*b7+a7*b2;
          res.d[4]=a2*b5+a5*b2-a1*b6-a6*b1;
          res.d[5]=a0*b6+a6*b0-a2*b4-a4*b2;
          res.d[6]=a1*b4+a4*b1-a0*b5-a5*b0;
          res.d[7]=0.0;
          return res;
    }
}

impl vector_t {
    pub fn lip(a: scalar_t, b: vector_t) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 4 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          res.d[3]=a*b3;
          return res;
    }
}

impl bivector_t {
    pub fn lip(a: scalar_t, b: bivector_t) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          res.d[3]=a*b3;
          res.d[4]=a*b4;
          res.d[5]=a*b5;
          return res;
    }
}

impl trivector_t {
    pub fn lip(a: scalar_t, b: trivector_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          res.d[3]=a*b3;
          return res;
    }
}

impl quadvector_t {
    pub fn lip(a: scalar_t, b: quadvector_t) -> quadvector_t {
        let mut res = quadvector_t::new(0.0);
          // a
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
          let b0=b.d[0];
          res.d[0]=a*b0;
          return res;
    }
}

impl horizon_t {
    pub fn lip(a: scalar_t, b: horizon_t) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a;
          return res;
    }
}

impl origin_t {
    pub fn lip(a: scalar_t, b: origin_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a;
          return res;
    }
}

impl point_t {
    pub fn lip(a: scalar_t, b: point_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          res.d[3]=a;
          return res;
    }
}

impl direction_t {
    pub fn lip(a: scalar_t, b: direction_t) -> direction_t {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          return res;
    }
}

impl ebivector_t {
    pub fn lip(a: scalar_t, b: ebivector_t) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 3 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          return res;
    }
}

impl ibivector_t {
    pub fn lip(a: scalar_t, b: ibivector_t) -> ibivector_t {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          return res;
    }
}

impl evector_t {
    pub fn lip(a: scalar_t, b: evector_t) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          return res;
    }
}

impl dpoint_t {
    pub fn lip(a: scalar_t, b: dpoint_t) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          res.d[3]=a;
          return res;
    }
}

impl rotation_t {
    pub fn lip(a: scalar_t, b: rotation_t) -> rotation_t {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 4 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          res.d[3]=a*b3;
          return res;
    }
}

impl translation_t {
    pub fn lip(a: scalar_t, b: translation_t) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=a;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a*b0;
          res.d[5]=a*b1;
          res.d[6]=a*b2;
          res.d[7]=0.0;
          return res;
    }
}

impl even_t {
    pub fn lip(a: scalar_t, b: even_t) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 8 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
        let b6=b.d[6];
        let b7=b.d[7];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          res.d[3]=a*b3;
          res.d[4]=a*b4;
          res.d[5]=a*b5;
          res.d[6]=a*b6;
          res.d[7]=a*b7;
          return res;
    }
}

impl odd_t {
    pub fn lip(a: scalar_t, b: odd_t) -> odd_t {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 8 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
        let b6=b.d[6];
        let b7=b.d[7];
          res.d[0]=a*b0;
          res.d[1]=a*b1;
          res.d[2]=a*b2;
          res.d[3]=a*b3;
          res.d[4]=a*b4;
          res.d[5]=a*b5;
          res.d[6]=a*b6;
          res.d[7]=a*b7;
          return res;
    }
}

impl vector_t {
    pub fn rip(a: scalar_t, b: vector_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl bivector_t {
    pub fn rip(a: scalar_t, b: bivector_t) -> scalar_t {
        
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl trivector_t {
    pub fn rip(a: scalar_t, b: trivector_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl quadvector_t {
    pub fn rip(a: scalar_t, b: quadvector_t) -> scalar_t {
        
          // a
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl horizon_t {
    pub fn rip(a: scalar_t, b: horizon_t) -> scalar_t {
        
          // a
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl origin_t {
    pub fn rip(a: scalar_t, b: origin_t) -> scalar_t {
        
          // a
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl point_t {
    pub fn rip(a: scalar_t, b: point_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl direction_t {
    pub fn rip(a: scalar_t, b: direction_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl ebivector_t {
    pub fn rip(a: scalar_t, b: ebivector_t) -> scalar_t {
        
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl ibivector_t {
    pub fn rip(a: scalar_t, b: ibivector_t) -> scalar_t {
        
          // a
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl evector_t {
    pub fn rip(a: scalar_t, b: evector_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl dpoint_t {
    pub fn rip(a: scalar_t, b: dpoint_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl rotation_t {
    pub fn rip(a: scalar_t, b: rotation_t) -> scalar_t {
        
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 1 muls / 0 adds
          let b0=b.d[0];
          return a*b0;
        
    }
}

impl translation_t {
    pub fn rip(a: scalar_t, b: translation_t) -> scalar_t {
        
          // a
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return a;
        
    }
}

impl even_t {
    pub fn rip(a: scalar_t, b: even_t) -> scalar_t {
        
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r
          // 1 muls / 0 adds
          let b0=b.d[0];
          return a*b0;
        
    }
}

impl odd_t {
    pub fn rip(a: scalar_t, b: odd_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of vector (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl vector_t {
    pub fn reverse(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of bivector (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl bivector_t {
    pub fn reverse(self) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 6 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          res.d[4]=-self.d[4];
          res.d[5]=-self.d[5];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of trivector (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl trivector_t {
    pub fn reverse(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of quadvector (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl quadvector_t {
    pub fn reverse(self) -> quadvector_t {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of horizon (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl horizon_t {
    pub fn reverse(self) -> horizon_t {
        let mut res = horizon_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of origin (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl origin_t {
    pub fn reverse(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of point (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl point_t {
    pub fn reverse(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of direction (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl direction_t {
    pub fn reverse(self) -> direction_t {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of ebivector (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl ebivector_t {
    pub fn reverse(self) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 3 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of ibivector (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl ibivector_t {
    pub fn reverse(self) -> ibivector_t {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of evector (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl evector_t {
    pub fn reverse(self) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of dpoint (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl dpoint_t {
    pub fn reverse(self) -> dpoint_t {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of rotation (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl rotation_t {
    pub fn reverse(self) -> rotation_t {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 3 adds
          res.d[0]=self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of translation (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl translation_t {
    pub fn reverse(self) -> translation_t {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of even (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl even_t {
    pub fn reverse(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
          res.d[0]=self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          res.d[4]=-self.d[4];
          res.d[5]=-self.d[5];
          res.d[6]=-self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of odd (implemented as a method since '~' operator overloading is not available)
////////////////////////////////////////////////////////////////////////////////  
impl odd_t {
    pub fn reverse(self) -> odd_t {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=-self.d[4];
          res.d[5]=-self.d[5];
          res.d[6]=-self.d[6];
          res.d[7]=-self.d[7];
          return res;
    }
}

impl vector_t {
    pub fn involute(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          return res;
    }
}

impl bivector_t {
    pub fn involute(self) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          return res;
    }
}

impl trivector_t {
    pub fn involute(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          return res;
    }
}

impl quadvector_t {
    pub fn involute(self) -> quadvector_t {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          return res;
    }
}

impl horizon_t {
    pub fn involute(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          return res;
    }
}

impl origin_t {
    pub fn involute(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          return res;
    }
}

impl point_t {
    pub fn involute(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-1.0;
          return res;
    }
}

impl direction_t {
    pub fn involute(self) -> direction_t {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          return res;
    }
}

impl ebivector_t {
    pub fn involute(self) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

impl ibivector_t {
    pub fn involute(self) -> ibivector_t {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

impl evector_t {
    pub fn involute(self) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          return res;
    }
}

impl dpoint_t {
    pub fn involute(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-1.0;
          return res;
    }
}

impl rotation_t {
    pub fn involute(self) -> rotation_t {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          return res;
    }
}

impl translation_t {
    pub fn involute(self) -> translation_t {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

impl even_t {
    pub fn involute(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          res.d[4]=self.d[4];
          res.d[5]=self.d[5];
          res.d[6]=self.d[6];
          res.d[7]=self.d[7];
          return res;
    }
}

impl odd_t {
    pub fn involute(self) -> odd_t {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 8 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          res.d[4]=-self.d[4];
          res.d[5]=-self.d[5];
          res.d[6]=-self.d[6];
          res.d[7]=-self.d[7];
          return res;
    }
}

impl vector_t {
    pub fn conjugate(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-a3;
          return res;
    }
}

impl bivector_t {
    pub fn conjugate(self) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-a3;
          res.d[4]=-a4;
          res.d[5]=-a5;
          return res;
    }
}

impl trivector_t {
    pub fn conjugate(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          return res;
    }
}

impl quadvector_t {
    pub fn conjugate(self) -> quadvector_t {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=a0;
          return res;
    }
}

impl horizon_t {
    pub fn conjugate(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          return res;
    }
}

impl origin_t {
    pub fn conjugate(self) -> origin_t {
        let mut res = origin_t::new();
            return res;
        
    }
}

impl point_t {
    pub fn conjugate(self) -> point_t {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

impl direction_t {
    pub fn conjugate(self) -> direction_t {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

impl ebivector_t {
    pub fn conjugate(self) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

impl ibivector_t {
    pub fn conjugate(self) -> ibivector_t {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

impl evector_t {
    pub fn conjugate(self) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

impl dpoint_t {
    pub fn conjugate(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-1.0;
          return res;
    }
}

impl rotation_t {
    pub fn conjugate(self) -> rotation_t {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-a3;
          return res;
    }
}

impl translation_t {
    pub fn conjugate(self) -> translation_t {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

impl even_t {
    pub fn conjugate(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-a3;
          res.d[4]=-a4;
          res.d[5]=-a5;
          res.d[6]=-a6;
          res.d[7]=a7;
          return res;
    }
}

impl odd_t {
    pub fn conjugate(self) -> odd_t {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-a3;
          res.d[4]=a4;
          res.d[5]=a5;
          res.d[6]=a6;
          res.d[7]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for vector_t {
    type Output = trivector_t;
    fn not(self) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          res.d[3]=self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for bivector_t {
    type Output = bivector_t;
    fn not(self) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 0 adds
          res.d[0]=self.d[3];
          res.d[1]=self.d[4];
          res.d[2]=self.d[5];
          res.d[3]=self.d[0];
          res.d[4]=self.d[1];
          res.d[5]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for trivector_t {
    type Output = vector_t;
    fn not(self) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-self.d[3];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for quadvector_t {
    type Output = scalar_t;
    fn not(self) -> Self::Output {
        
          // a0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return self.d[0];
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for horizon_t {
    type Output = origin_t;
    fn not(self) -> Self::Output {
        let mut res = origin_t::new();
            return res;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for origin_t {
    type Output = vector_t;
    fn not(self) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for point_t {
    type Output = vector_t;
    fn not(self) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 4 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          res.d[3]=-1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for direction_t {
    type Output = evector_t;
    fn not(self) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 3 adds
          res.d[0]=-self.d[0];
          res.d[1]=-self.d[1];
          res.d[2]=-self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for ebivector_t {
    type Output = ibivector_t;
    fn not(self) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for ibivector_t {
    type Output = ebivector_t;
    fn not(self) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for evector_t {
    type Output = direction_t;
    fn not(self) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for dpoint_t {
    type Output = point_t;
    fn not(self) -> Self::Output {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[0];
          res.d[1]=self.d[1];
          res.d[2]=self.d[2];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for rotation_t {
    type Output = even_t;
    fn not(self) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=self.d[1];
          res.d[5]=self.d[2];
          res.d[6]=self.d[3];
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for translation_t {
    type Output = even_t;
    fn not(self) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=self.d[0];
          res.d[2]=self.d[1];
          res.d[3]=self.d[2];
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for even_t {
    type Output = even_t;
    fn not(self) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
          res.d[0]=self.d[7];
          res.d[1]=self.d[4];
          res.d[2]=self.d[5];
          res.d[3]=self.d[6];
          res.d[4]=self.d[1];
          res.d[5]=self.d[2];
          res.d[6]=self.d[3];
          res.d[7]=self.d[0];
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// dual of odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::Not for odd_t {
    type Output = odd_t;
    fn not(self) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
          res.d[0]=-self.d[4];
          res.d[1]=-self.d[5];
          res.d[2]=-self.d[6];
          res.d[3]=-self.d[7];
          res.d[4]=self.d[0];
          res.d[5]=self.d[1];
          res.d[6]=self.d[2];
          res.d[7]=self.d[3];
          return res;
    }
}

impl vector_t {
    pub fn undual(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-a3;
          return res;
    }
}

impl bivector_t {
    pub fn undual(self) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
          res.d[0]=a3;
          res.d[1]=a4;
          res.d[2]=a5;
          res.d[3]=a0;
          res.d[4]=a1;
          res.d[5]=a2;
          return res;
    }
}

impl trivector_t {
    pub fn undual(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=a3;
          return res;
    }
}

impl quadvector_t {
    pub fn undual(self) -> scalar_t {
        
          // a0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          let a0=self.d[0];
          return a0;
        
    }
}

impl horizon_t {
    pub fn undual(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          return res;
    }
}

impl origin_t {
    pub fn undual(self) -> horizon_t {
        let mut res = horizon_t::new();
            return res;
        
    }
}

impl point_t {
    pub fn undual(self) -> dpoint_t {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

impl direction_t {
    pub fn undual(self) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

impl ebivector_t {
    pub fn undual(self) -> ibivector_t {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

impl ibivector_t {
    pub fn undual(self) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

impl evector_t {
    pub fn undual(self) -> direction_t {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

impl dpoint_t {
    pub fn undual(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-1.0;
          return res;
    }
}

impl rotation_t {
    pub fn undual(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a1;
          res.d[5]=a2;
          res.d[6]=a3;
          res.d[7]=a0;
          return res;
    }
}

impl translation_t {
    pub fn undual(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=0.0;
          res.d[1]=a0;
          res.d[2]=a1;
          res.d[3]=a2;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=1.0;
          return res;
    }
}

impl even_t {
    pub fn undual(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=a7;
          res.d[1]=a4;
          res.d[2]=a5;
          res.d[3]=a6;
          res.d[4]=a1;
          res.d[5]=a2;
          res.d[6]=a3;
          res.d[7]=a0;
          return res;
    }
}

impl odd_t {
    pub fn undual(self) -> odd_t {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=a4;
          res.d[1]=a5;
          res.d[2]=a6;
          res.d[3]=a7;
          res.d[4]=-a0;
          res.d[5]=-a1;
          res.d[6]=-a2;
          res.d[7]=-a3;
          return res;
    }
}

impl vector_t {
    pub fn prj(a: scalar_t, b: vector_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 6 muls / 2 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          return a*b0*b0+a*b1*b1+a*b2*b2;
        
    }
}

impl bivector_t {
    pub fn prj(a: scalar_t, b: bivector_t) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 9 muls / 4 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
          res.d[0]=a*(b0*b0+b1*b1+b2*b2);
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=2.0*(a*(b0*b3+b1*b4+b2*b5));
          return res;
    }
}

impl trivector_t {
    pub fn prj(a: scalar_t, b: trivector_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 2 muls / 0 adds
          let b3=b.d[3];
          return a*b3*b3;
        
    }
}

impl quadvector_t {
    pub fn prj(a: scalar_t, b: quadvector_t) -> scalar_t {
        
          // a
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl horizon_t {
    pub fn prj(a: scalar_t, b: horizon_t) -> scalar_t {
        
          // a
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl origin_t {
    pub fn prj(a: scalar_t, b: origin_t) -> scalar_t {
        
          // a
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return a;
        
    }
}

impl point_t {
    pub fn prj(a: scalar_t, b: point_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return a;
        
    }
}

impl direction_t {
    pub fn prj(a: scalar_t, b: direction_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl ebivector_t {
    pub fn prj(a: scalar_t, b: ebivector_t) -> scalar_t {
        
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 6 muls / 2 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          return a*b0*b0+a*b1*b1+a*b2*b2;
        
    }
}

impl ibivector_t {
    pub fn prj(a: scalar_t, b: ibivector_t) -> scalar_t {
        
          // a
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl evector_t {
    pub fn prj(a: scalar_t, b: evector_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 6 muls / 2 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          return a*b0*b0+a*b1*b1+a*b2*b2;
        
    }
}

impl dpoint_t {
    pub fn prj(a: scalar_t, b: dpoint_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 6 muls / 2 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          return a*b0*b0+a*b1*b1+a*b2*b2;
        
    }
}

impl rotation_t {
    pub fn prj(a: scalar_t, b: rotation_t) -> scalar_t {
        
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 8 muls / 3 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
          return a*b0*b0+a*b1*b1+a*b2*b2+a*b3*b3;
        
    }
}

impl translation_t {
    pub fn prj(a: scalar_t, b: translation_t) -> scalar_t {
        
          // a
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return a;
        
    }
}

impl even_t {
    pub fn prj(a: scalar_t, b: even_t) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 11 muls / 6 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
        let b6=b.d[6];
        let b7=b.d[7];
          res.d[0]=a*(b0*b0+b1*b1+b2*b2+b3*b3);
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=2.0*(a*(b0*b7-b1*b4-b2*b5-b3*b6));
          return res;
    }
}

impl odd_t {
    pub fn prj(a: scalar_t, b: odd_t) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 11 muls / 6 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
        let b6=b.d[6];
        let b7=b.d[7];
          res.d[0]=a*(b0*b0+b1*b1+b2*b2+b7*b7);
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=2.0*(a*(b0*b4+b1*b5+b2*b6+b3*b7));
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for trivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for quadvector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₀₁₂₃
          // -> r
          // 1 muls / 0 adds
          let b0=self.d[0];
          return rhs*b0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for origin_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for point_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for direction_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for even_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r
          // 1 muls / 0 adds
          let b7=self.d[7];
          return rhs*b7;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<scalar_t> for odd_t {
    type Output = scalar_t;
    fn bitand(self, rhs: scalar_t) -> Self::Output {
        
          // rhs
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 4 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          return a0*b0+a1*b1+a2*b2+a3*b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for vector_t {
    type Output = vector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 4 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          let a3=self.d[3];
          return a3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2+a3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for vector_t {
    type Output = vector_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 4 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b7=rhs.d[7];
          res.d[0]=a0*b7;
          res.d[1]=a1*b7;
          res.d[2]=a2*b7;
          res.d[3]=a3*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for vector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 4 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          return a0*b4+a1*b5+a2*b6+a3*b7;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 6 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          return a0*b3+a1*b4+a2*b5+a3*b0+a4*b1+a5*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for bivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a1*b2+a3*b3-a2*b1;
          res.d[1]=a2*b0+a4*b3-a0*b2;
          res.d[2]=a0*b1+a5*b3-a1*b0;
          res.d[3]=-a3*b0-a4*b1-a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for bivector_t {
    type Output = bivector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          res.d[4]=a4*b0;
          res.d[5]=a5*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for bivector_t {
    type Output = evector_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
          res.d[0]=a3;
          res.d[1]=a4;
          res.d[2]=a5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for bivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2+a3-a2*b1;
          res.d[1]=a2*b0+a4-a0*b2;
          res.d[2]=a0*b1+a5-a1*b0;
          res.d[3]=-a3*b0-a4*b1-a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for bivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          res.d[3]=-a3*b0-a4*b1-a5*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 3 muls / 2 adds
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a3*b0+a4*b1+a5*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 3 muls / 2 adds
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          return a3*b1+a4*b2+a5*b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for bivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for bivector_t {
    type Output = even_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b4+a1*b5+a2*b6+a3*b1+a4*b2+a5*b3;
          res.d[1]=a0*b7;
          res.d[2]=a1*b7;
          res.d[3]=a2*b7;
          res.d[4]=a3*b7;
          res.d[5]=a4*b7;
          res.d[6]=a5*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for bivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a1*b6+a3*b7-a2*b5;
          res.d[1]=a2*b4+a4*b7-a0*b6;
          res.d[2]=a0*b5+a5*b7-a1*b4;
          res.d[3]=-a3*b4-a4*b5-a5*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for trivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 4 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          return -a0*b0-a1*b1-a2*b2-a3*b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for trivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1+a3*b3-a1*b2;
          res.d[1]=a0*b2+a3*b4-a2*b0;
          res.d[2]=a1*b0+a3*b5-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for trivector_t {
    type Output = bivector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 12 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a3*b0-a0*b3;
          res.d[1]=a3*b1-a1*b3;
          res.d[2]=a3*b2-a2*b3;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for trivector_t {
    type Output = trivector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for trivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 1 adds
          let a3=self.d[3];
          return -a3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for trivector_t {
    type Output = ebivector_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for trivector_t {
    type Output = bivector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0-a0;
          res.d[1]=a3*b1-a1;
          res.d[2]=a3*b2-a2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for trivector_t {
    type Output = bivector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0;
          res.d[1]=a3*b1;
          res.d[2]=a3*b2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for trivector_t {
    type Output = evector_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for trivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0;
          res.d[1]=a3*b1;
          res.d[2]=a3*b2;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for trivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for trivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2-a3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for trivector_t {
    type Output = evector_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a2*b2-a1*b3;
          res.d[1]=a0*b3-a2*b1;
          res.d[2]=a1*b1-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for trivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a3*b0;
          res.d[1]=a3*b1;
          res.d[2]=a3*b2;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for trivector_t {
    type Output = odd_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a2*b2+a3*b4-a1*b3;
          res.d[1]=a0*b3+a3*b5-a2*b1;
          res.d[2]=a1*b1+a3*b6-a0*b2;
          res.d[3]=-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7;
          res.d[5]=a1*b7;
          res.d[6]=a2*b7;
          res.d[7]=a3*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for trivector_t {
    type Output = even_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 16 muls / 10 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-a0*b0-a1*b1-a2*b2-a3*b3;
          res.d[1]=a3*b4-a0*b7;
          res.d[2]=a3*b5-a1*b7;
          res.d[3]=a3*b6-a2*b7;
          res.d[4]=a1*b6-a2*b5;
          res.d[5]=a2*b4-a0*b6;
          res.d[6]=a0*b5-a1*b4;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for quadvector_t {
    type Output = vector_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 4 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for quadvector_t {
    type Output = bivector_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          res.d[4]=a0*b4;
          res.d[5]=a0*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for quadvector_t {
    type Output = trivector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 4 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for quadvector_t {
    type Output = quadvector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 1 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for quadvector_t {
    type Output = vector_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for quadvector_t {
    type Output = trivector_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for quadvector_t {
    type Output = trivector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for quadvector_t {
    type Output = direction_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for quadvector_t {
    type Output = ebivector_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for quadvector_t {
    type Output = ibivector_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for quadvector_t {
    type Output = evector_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for quadvector_t {
    type Output = vector_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for quadvector_t {
    type Output = rotation_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 4 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for quadvector_t {
    type Output = even_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0;
          res.d[5]=a0*b1;
          res.d[6]=a0*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for quadvector_t {
    type Output = even_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 8 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          res.d[4]=a0*b4;
          res.d[5]=a0*b5;
          res.d[6]=a0*b6;
          res.d[7]=a0*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for quadvector_t {
    type Output = odd_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 8 muls / 0 adds
        let a0=self.d[0];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b0;
          res.d[1]=a0*b1;
          res.d[2]=a0*b2;
          res.d[3]=a0*b3;
          res.d[4]=a0*b4;
          res.d[5]=a0*b5;
          res.d[6]=a0*b6;
          res.d[7]=a0*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          let b3=rhs.d[3];
          return b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for horizon_t {
    type Output = vector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // 1 e₀
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for horizon_t {
    type Output = translation_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 e₀
          // 1 e₁₂₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for horizon_t {
    type Output = translation_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // 1 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for horizon_t {
    type Output = vector_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let b7=rhs.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for horizon_t {
    type Output = scalar_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        
          // 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          let b7=rhs.d[7];
          return b7;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for origin_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 1 adds
          let b3=rhs.d[3];
          return -b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for origin_t {
    type Output = evector_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=b3;
          res.d[1]=b4;
          res.d[2]=b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for origin_t {
    type Output = ebivector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for origin_t {
    type Output = trivector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
          let b0=rhs.d[0];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for origin_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // 1 e₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 1 adds
          return -1.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for origin_t {
    type Output = scalar_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        
          // 1 e₁₂₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for origin_t {
    type Output = ebivector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for origin_t {
    type Output = ebivector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for origin_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for origin_t {
    type Output = evector_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for origin_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for origin_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 1 adds
          return -1.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for origin_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for origin_t {
    type Output = evector_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // 1 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for origin_t {
    type Output = odd_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=b4;
          res.d[1]=b5;
          res.d[2]=b6;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for origin_t {
    type Output = rotation_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 1 adds
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=-b3;
          res.d[1]=b4;
          res.d[2]=b5;
          res.d[3]=b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for point_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          return -a0*b0-a1*b1-a2*b2-b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for point_t {
    type Output = vector_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1+b3-a1*b2;
          res.d[1]=a0*b2+b4-a2*b0;
          res.d[2]=a1*b0+b5-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for point_t {
    type Output = bivector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=b0-a0*b3;
          res.d[1]=b1-a1*b3;
          res.d[2]=b2-a2*b3;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for point_t {
    type Output = trivector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for point_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 1 adds
          return -1.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for point_t {
    type Output = ebivector_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for point_t {
    type Output = bivector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0-a0;
          res.d[1]=b1-a1;
          res.d[2]=b2-a2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for point_t {
    type Output = bivector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for point_t {
    type Output = evector_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for point_t {
    type Output = vector_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for point_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for point_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -1.0-a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for point_t {
    type Output = evector_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a2*b2-a1*b3;
          res.d[1]=a0*b3-a2*b1;
          res.d[2]=a1*b1-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for point_t {
    type Output = vector_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for point_t {
    type Output = odd_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a2*b2+b4-a1*b3;
          res.d[1]=a0*b3+b5-a2*b1;
          res.d[2]=a1*b1+b6-a0*b2;
          res.d[3]=-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7;
          res.d[5]=a1*b7;
          res.d[6]=a2*b7;
          res.d[7]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for point_t {
    type Output = even_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 10 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-a0*b0-a1*b1-a2*b2-b3;
          res.d[1]=b4-a0*b7;
          res.d[2]=b5-a1*b7;
          res.d[3]=b6-a2*b7;
          res.d[4]=a1*b6-a2*b5;
          res.d[5]=a2*b4-a0*b6;
          res.d[6]=a0*b5-a1*b4;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for direction_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for direction_t {
    type Output = vector_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          res.d[3]=-a0*b3-a1*b4-a2*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for direction_t {
    type Output = bivector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=-a0*b3;
          res.d[1]=-a1*b3;
          res.d[2]=-a2*b3;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for direction_t {
    type Output = direction_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for direction_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for direction_t {
    type Output = ebivector_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for direction_t {
    type Output = bivector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 6 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=a1*b2-a2*b1;
          res.d[4]=a2*b0-a0*b2;
          res.d[5]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for direction_t {
    type Output = ibivector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for direction_t {
    type Output = evector_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b1-a1*b2;
          res.d[1]=a0*b2-a2*b0;
          res.d[2]=a1*b0-a0*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for direction_t {
    type Output = vector_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for direction_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for direction_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a0*b0-a1*b1-a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for direction_t {
    type Output = evector_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a2*b2-a1*b3;
          res.d[1]=a0*b3-a2*b1;
          res.d[2]=a1*b1-a0*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for direction_t {
    type Output = vector_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for direction_t {
    type Output = odd_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a2*b2-a1*b3;
          res.d[1]=a0*b3-a2*b1;
          res.d[2]=a1*b1-a0*b2;
          res.d[3]=-a0*b4-a1*b5-a2*b6;
          res.d[4]=a0*b7;
          res.d[5]=a1*b7;
          res.d[6]=a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for direction_t {
    type Output = even_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=-a0*b0-a1*b1-a2*b2;
          res.d[1]=-a0*b7;
          res.d[2]=-a1*b7;
          res.d[3]=-a2*b7;
          res.d[4]=a1*b6-a2*b5;
          res.d[5]=a2*b4-a0*b6;
          res.d[6]=a0*b5-a1*b4;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          return a0*b3+a1*b4+a2*b5;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for ebivector_t {
    type Output = evector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for ebivector_t {
    type Output = ebivector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁₂₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for ebivector_t {
    type Output = evector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for ebivector_t {
    type Output = evector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b2-a2*b1;
          res.d[1]=a2*b0-a0*b2;
          res.d[2]=a0*b1-a1*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for ebivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for ebivector_t {
    type Output = rotation_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b4+a1*b5+a2*b6;
          res.d[1]=a0*b7;
          res.d[2]=a1*b7;
          res.d[3]=a2*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for ebivector_t {
    type Output = evector_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=a1*b6-a2*b5;
          res.d[1]=a2*b4-a0*b6;
          res.d[2]=a0*b5-a1*b4;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for ibivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b3;
          res.d[1]=a1*b3;
          res.d[2]=a2*b3;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for ibivector_t {
    type Output = ibivector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for ibivector_t {
    type Output = evector_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for ibivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for ibivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          return a0*b1+a1*b2+a2*b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for ibivector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for ibivector_t {
    type Output = even_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b7=rhs.d[7];
          res.d[0]=a0*b1+a1*b2+a2*b3;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b7;
          res.d[5]=a1*b7;
          res.d[6]=a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for ibivector_t {
    type Output = vector_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b7;
          res.d[1]=a1*b7;
          res.d[2]=a2*b7;
          res.d[3]=-a0*b4-a1*b5-a2*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for evector_t {
    type Output = evector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for evector_t {
    type Output = evector_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b7=rhs.d[7];
          res.d[0]=a0*b7;
          res.d[1]=a1*b7;
          res.d[2]=a2*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for evector_t {
    type Output = scalar_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          return a0*b4+a1*b5+a2*b6;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          return a0*b0+a1*b1+a2*b2+b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for dpoint_t {
    type Output = vector_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for dpoint_t {
    type Output = translation_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 e₁₂₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return 1.0+a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for dpoint_t {
    type Output = vector_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b7=rhs.d[7];
          res.d[0]=a0*b7;
          res.d[1]=a1*b7;
          res.d[2]=a2*b7;
          res.d[3]=b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for dpoint_t {
    type Output = scalar_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          return a0*b4+a1*b5+a2*b6+b7;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          return a1*b3+a2*b4+a3*b5;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for rotation_t {
    type Output = evector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b2-a3*b1;
          res.d[1]=a3*b0-a1*b2;
          res.d[2]=a1*b1-a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for rotation_t {
    type Output = rotation_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 4 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for rotation_t {
    type Output = evector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b2-a3*b1;
          res.d[1]=a3*b0-a1*b2;
          res.d[2]=a1*b1-a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for rotation_t {
    type Output = evector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b2-a3*b1;
          res.d[1]=a3*b0-a1*b2;
          res.d[2]=a1*b1-a2*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a1*b0+a2*b1+a3*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for rotation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a1*b0+a2*b1+a3*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for rotation_t {
    type Output = rotation_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 7 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b7+a1*b4+a2*b5+a3*b6;
          res.d[1]=a1*b7;
          res.d[2]=a2*b7;
          res.d[3]=a3*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for rotation_t {
    type Output = evector_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
          res.d[0]=a2*b6-a3*b5;
          res.d[1]=a3*b4-a1*b6;
          res.d[2]=a1*b5-a2*b4;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for translation_t {
    type Output = vector_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b3;
          res.d[1]=a1*b3;
          res.d[2]=a2*b3;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for translation_t {
    type Output = even_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 3 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
          res.d[0]=b0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b0;
          res.d[5]=a1*b0;
          res.d[6]=a2*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for translation_t {
    type Output = evector_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for translation_t {
    type Output = vector_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0;
          res.d[1]=a1;
          res.d[2]=a2;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for translation_t {
    type Output = vector_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-a0*b0-a1*b1-a2*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return a0*b0+a1*b1+a2*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 3 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          return a0*b1+a1*b2+a2*b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for translation_t {
    type Output = scalar_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for translation_t {
    type Output = even_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b7=rhs.d[7];
          res.d[0]=a0*b1+a1*b2+a2*b3+b7;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a0*b7;
          res.d[5]=a1*b7;
          res.d[6]=a2*b7;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for translation_t {
    type Output = vector_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b7;
          res.d[1]=a1*b7;
          res.d[2]=a2*b7;
          res.d[3]=-a0*b4-a1*b5-a2*b6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for even_t {
    type Output = vector_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 4 muls / 0 adds
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a7*b0;
          res.d[1]=a7*b1;
          res.d[2]=a7*b2;
          res.d[3]=a7*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for even_t {
    type Output = even_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a1*b3+a2*b4+a3*b5+a4*b0+a5*b1+a6*b2;
          res.d[1]=a7*b0;
          res.d[2]=a7*b1;
          res.d[3]=a7*b2;
          res.d[4]=a7*b3;
          res.d[5]=a7*b4;
          res.d[6]=a7*b5;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for even_t {
    type Output = odd_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 16 muls / 9 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a2*b2+a4*b3-a3*b1;
          res.d[1]=a3*b0+a5*b3-a1*b2;
          res.d[2]=a1*b1+a6*b3-a2*b0;
          res.d[3]=-a4*b0-a5*b1-a6*b2;
          res.d[4]=a7*b0;
          res.d[5]=a7*b1;
          res.d[6]=a7*b2;
          res.d[7]=a7*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for even_t {
    type Output = even_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 8 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          res.d[4]=a4*b0;
          res.d[5]=a5*b0;
          res.d[6]=a6*b0;
          res.d[7]=a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for even_t {
    type Output = vector_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
          let a7=self.d[7];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for even_t {
    type Output = odd_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=a4;
          res.d[1]=a5;
          res.d[2]=a6;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for even_t {
    type Output = odd_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 9 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b2+a4-a3*b1;
          res.d[1]=a3*b0+a5-a1*b2;
          res.d[2]=a1*b1+a6-a2*b0;
          res.d[3]=-a4*b0-a5*b1-a6*b2;
          res.d[4]=a7*b0;
          res.d[5]=a7*b1;
          res.d[6]=a7*b2;
          res.d[7]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for even_t {
    type Output = odd_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 12 muls / 6 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a2*b2-a3*b1;
          res.d[1]=a3*b0-a1*b2;
          res.d[2]=a1*b1-a2*b0;
          res.d[3]=-a4*b0-a5*b1-a6*b2;
          res.d[4]=a7*b0;
          res.d[5]=a7*b1;
          res.d[6]=a7*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for even_t {
    type Output = rotation_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 6 muls / 2 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a4*b0+a5*b1+a6*b2;
          res.d[1]=a7*b0;
          res.d[2]=a7*b1;
          res.d[3]=a7*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for even_t {
    type Output = even_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 2 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b0+a2*b1+a3*b2;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a7*b0;
          res.d[5]=a7*b1;
          res.d[6]=a7*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for even_t {
    type Output = evector_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a7*b0;
          res.d[1]=a7*b1;
          res.d[2]=a7*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for even_t {
    type Output = vector_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 3 muls / 0 adds
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a7*b0;
          res.d[1]=a7*b1;
          res.d[2]=a7*b2;
          res.d[3]=a7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for even_t {
    type Output = rotation_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 7 muls / 3 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a4*b1+a5*b2+a6*b3+a7*b0;
          res.d[1]=a7*b1;
          res.d[2]=a7*b2;
          res.d[3]=a7*b3;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for even_t {
    type Output = even_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 6 muls / 3 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a1*b0+a2*b1+a3*b2+a7;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=a7*b0;
          res.d[5]=a7*b1;
          res.d[6]=a7*b2;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for even_t {
    type Output = even_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 21 muls / 13 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b7+a1*b4+a2*b5+a3*b6+a4*b1+a5*b2+a6*b3+a7*b0;
          res.d[1]=a1*b7+a7*b1;
          res.d[2]=a2*b7+a7*b2;
          res.d[3]=a3*b7+a7*b3;
          res.d[4]=a4*b7+a7*b4;
          res.d[5]=a5*b7+a7*b5;
          res.d[6]=a6*b7+a7*b6;
          res.d[7]=a7*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<odd_t> for even_t {
    type Output = odd_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 20 muls / 12 adds
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a2*b6+a4*b7+a7*b0-a3*b5;
          res.d[1]=a3*b4+a5*b7+a7*b1-a1*b6;
          res.d[2]=a1*b5+a6*b7+a7*b2-a2*b4;
          res.d[3]=a7*b3-a4*b4-a5*b5-a6*b6;
          res.d[4]=a7*b4;
          res.d[5]=a7*b5;
          res.d[6]=a7*b6;
          res.d[7]=a7*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and vector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<vector_t> for odd_t {
    type Output = scalar_t;
    fn bitand(self, rhs: vector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 4 muls / 4 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          return -a4*b0-a5*b1-a6*b2-a7*b3;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and bivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<bivector_t> for odd_t {
    type Output = vector_t;
    fn bitand(self, rhs: bivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 12 muls / 9 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
          res.d[0]=a6*b1+a7*b3-a5*b2;
          res.d[1]=a4*b2+a7*b4-a6*b0;
          res.d[2]=a5*b0+a7*b5-a4*b1;
          res.d[3]=-a4*b3-a5*b4-a6*b5;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and trivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<trivector_t> for odd_t {
    type Output = even_t;
    fn bitand(self, rhs: trivector_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 16 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a0*b0+a1*b1+a2*b2+a3*b3;
          res.d[1]=a7*b0-a4*b3;
          res.d[2]=a7*b1-a5*b3;
          res.d[3]=a7*b2-a6*b3;
          res.d[4]=a5*b2-a6*b1;
          res.d[5]=a6*b0-a4*b2;
          res.d[6]=a4*b1-a5*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and quadvector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<quadvector_t> for odd_t {
    type Output = odd_t;
    fn bitand(self, rhs: quadvector_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 8 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
          res.d[0]=a0*b0;
          res.d[1]=a1*b0;
          res.d[2]=a2*b0;
          res.d[3]=a3*b0;
          res.d[4]=a4*b0;
          res.d[5]=a5*b0;
          res.d[6]=a6*b0;
          res.d[7]=a7*b0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and horizon
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<horizon_t> for odd_t {
    type Output = scalar_t;
    fn bitand(self, rhs: horizon_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₀
          // -> r
          // 0 muls / 1 adds
          let a7=self.d[7];
          return -a7;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and origin
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<origin_t> for odd_t {
    type Output = rotation_t;
    fn bitand(self, rhs: origin_t) -> Self::Output {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 3 adds
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
          res.d[0]=a3;
          res.d[1]=-a4;
          res.d[2]=-a5;
          res.d[3]=-a6;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and point
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<point_t> for odd_t {
    type Output = even_t;
    fn bitand(self, rhs: point_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2+a3;
          res.d[1]=a7*b0-a4;
          res.d[2]=a7*b1-a5;
          res.d[3]=a7*b2-a6;
          res.d[4]=a5*b2-a6*b1;
          res.d[5]=a6*b0-a4*b2;
          res.d[6]=a4*b1-a5*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and direction
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<direction_t> for odd_t {
    type Output = even_t;
    fn bitand(self, rhs: direction_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 12 muls / 5 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a0*b0+a1*b1+a2*b2;
          res.d[1]=a7*b0;
          res.d[2]=a7*b1;
          res.d[3]=a7*b2;
          res.d[4]=a5*b2-a6*b1;
          res.d[5]=a6*b0-a4*b2;
          res.d[6]=a4*b1-a5*b0;
          res.d[7]=0.0;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and ebivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ebivector_t> for odd_t {
    type Output = evector_t;
    fn bitand(self, rhs: ebivector_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a6*b1-a5*b2;
          res.d[1]=a4*b2-a6*b0;
          res.d[2]=a5*b0-a4*b1;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and ibivector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<ibivector_t> for odd_t {
    type Output = vector_t;
    fn bitand(self, rhs: ibivector_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 3 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a7*b0;
          res.d[1]=a7*b1;
          res.d[2]=a7*b2;
          res.d[3]=-a4*b0-a5*b1-a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and evector
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<evector_t> for odd_t {
    type Output = scalar_t;
    fn bitand(self, rhs: evector_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 3 muls / 3 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a4*b0-a5*b1-a6*b2;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and dpoint
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<dpoint_t> for odd_t {
    type Output = scalar_t;
    fn bitand(self, rhs: dpoint_t) -> Self::Output {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 3 muls / 4 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          return -a4*b0-a5*b1-a6*b2-a7;
        
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and rotation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<rotation_t> for odd_t {
    type Output = evector_t;
    fn bitand(self, rhs: rotation_t) -> Self::Output {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 6 muls / 3 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
          res.d[0]=a6*b2-a5*b3;
          res.d[1]=a4*b3-a6*b1;
          res.d[2]=a5*b1-a4*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and translation
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<translation_t> for odd_t {
    type Output = vector_t;
    fn bitand(self, rhs: translation_t) -> Self::Output {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 6 muls / 3 adds
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
          res.d[0]=a7*b0;
          res.d[1]=a7*b1;
          res.d[2]=a7*b2;
          res.d[3]=-a4*b0-a5*b1-a6*b2;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and even
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd<even_t> for odd_t {
    type Output = odd_t;
    fn bitand(self, rhs: even_t) -> Self::Output {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 20 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b7+a6*b2+a7*b4-a5*b3;
          res.d[1]=a1*b7+a4*b3+a7*b5-a6*b1;
          res.d[2]=a2*b7+a5*b1+a7*b6-a4*b2;
          res.d[3]=a3*b7-a4*b4-a5*b5-a6*b6;
          res.d[4]=a4*b7;
          res.d[5]=a5*b7;
          res.d[6]=a6*b7;
          res.d[7]=a7*b7;
          return res;
    }
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and odd
////////////////////////////////////////////////////////////////////////////////  
impl std::ops::BitAnd for odd_t {
    type Output = even_t;
    fn bitand(self, rhs: odd_t) -> Self::Output {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 20 muls / 13 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
        let b0=rhs.d[0];
        let b1=rhs.d[1];
        let b2=rhs.d[2];
        let b3=rhs.d[3];
        let b4=rhs.d[4];
        let b5=rhs.d[5];
        let b6=rhs.d[6];
        let b7=rhs.d[7];
          res.d[0]=a0*b4+a1*b5+a2*b6+a3*b7-a4*b0-a5*b1-a6*b2-a7*b3;
          res.d[1]=a7*b4-a4*b7;
          res.d[2]=a7*b5-a5*b7;
          res.d[3]=a7*b6-a6*b7;
          res.d[4]=a5*b6-a6*b5;
          res.d[5]=a6*b4-a4*b6;
          res.d[6]=a4*b5-a5*b4;
          res.d[7]=0.0;
          return res;
    }
}

impl vector_t {
    pub fn cp(a: scalar_t, b: vector_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl bivector_t {
    pub fn cp(a: scalar_t, b: bivector_t) -> scalar_t {
        
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl trivector_t {
    pub fn cp(a: scalar_t, b: trivector_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl quadvector_t {
    pub fn cp(a: scalar_t, b: quadvector_t) -> scalar_t {
        
          // a
          // b0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl horizon_t {
    pub fn cp(a: scalar_t, b: horizon_t) -> scalar_t {
        
          // a
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl origin_t {
    pub fn cp(a: scalar_t, b: origin_t) -> scalar_t {
        
          // a
          // 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl point_t {
    pub fn cp(a: scalar_t, b: point_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl direction_t {
    pub fn cp(a: scalar_t, b: direction_t) -> scalar_t {
        
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl ebivector_t {
    pub fn cp(a: scalar_t, b: ebivector_t) -> scalar_t {
        
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl ibivector_t {
    pub fn cp(a: scalar_t, b: ibivector_t) -> scalar_t {
        
          // a
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl evector_t {
    pub fn cp(a: scalar_t, b: evector_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl dpoint_t {
    pub fn cp(a: scalar_t, b: dpoint_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl rotation_t {
    pub fn cp(a: scalar_t, b: rotation_t) -> scalar_t {
        
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl translation_t {
    pub fn cp(a: scalar_t, b: translation_t) -> scalar_t {
        
          // a
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl even_t {
    pub fn cp(a: scalar_t, b: even_t) -> scalar_t {
        
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl odd_t {
    pub fn cp(a: scalar_t, b: odd_t) -> scalar_t {
        
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl vector_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r
          // 5 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          return (f32::abs(a0*a0+a1*a1+a2*a2)).powf(0.5);
        
    }
}

impl bivector_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r
          // 5 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          return (f32::abs(a0*a0+a1*a1+a2*a2)).powf(0.5);
        
    }
}

impl trivector_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r
          // 3 muls / 0 adds
          let a3=self.d[3];
          return (f32::abs(a3*a3)).powf(0.5);
        
    }
}

impl quadvector_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₀₁₂₃
          // -> r
          // 2 muls / 0 adds
          return (f32::abs(0.0)).powf(0.5);
        
    }
}

impl horizon_t {
    pub fn norm(self) -> scalar_t {
        
          // 1 e₀
          // -> r
          // 2 muls / 0 adds
          return (f32::abs(0.0)).powf(0.5);
        
    }
}

impl origin_t {
    pub fn norm(self) -> scalar_t {
        
          // 1 e₁₂₃
          // -> r
          // 2 muls / 0 adds
          return (f32::abs(1.0)).powf(0.5);
        
    }
}

impl point_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 2 muls / 0 adds
          return (f32::abs(1.0)).powf(0.5);
        
    }
}

impl direction_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r
          // 2 muls / 0 adds
          return (f32::abs(0.0)).powf(0.5);
        
    }
}

impl ebivector_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r
          // 5 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          return (f32::abs(a0*a0+a1*a1+a2*a2)).powf(0.5);
        
    }
}

impl ibivector_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r
          // 2 muls / 0 adds
          return (f32::abs(0.0)).powf(0.5);
        
    }
}

impl evector_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r
          // 5 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          return (f32::abs(a0*a0+a1*a1+a2*a2)).powf(0.5);
        
    }
}

impl dpoint_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r
          // 5 muls / 2 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          return (f32::abs(a0*a0+a1*a1+a2*a2)).powf(0.5);
        
    }
}

impl rotation_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          return (f32::abs(a0*a0+a1*a1+a2*a2+a3*a3)).powf(0.5);
        
    }
}

impl translation_t {
    pub fn norm(self) -> scalar_t {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r
          // 2 muls / 0 adds
          return (f32::abs(1.0)).powf(0.5);
        
    }
}

impl even_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          return (f32::abs(a0*a0+a1*a1+a2*a2+a3*a3)).powf(0.5);
        
    }
}

impl odd_t {
    pub fn norm(self) -> scalar_t {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r
          // 6 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a7=self.d[7];
          return (f32::abs(a0*a0+a1*a1+a2*a2+a7*a7)).powf(0.5);
        
    }
}

impl vector_t {
    pub fn normalized(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 20 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=(a0)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[1]=(a1)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[2]=(a2)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[3]=(a3)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          return res;
    }
}

impl bivector_t {
    pub fn normalized(self) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 210 muls / 75 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
          res.d[0]=(a0)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[1]=(a1)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[2]=(a2)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[3]=((a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*a3-(a0*a0+a1*a1+a2*a2).powf(0.5)*a0*a0*a3-(a0*a0+a1*a1+a2*a2).powf(0.5)*a0*a1*a4-(a0*a0+a1*a1+a2*a2).powf(0.5)*a0*a2*a5)/((a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[4]=((a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*a4-(a0*a0+a1*a1+a2*a2).powf(0.5)*a0*a1*a3-(a0*a0+a1*a1+a2*a2).powf(0.5)*a1*a1*a4-(a0*a0+a1*a1+a2*a2).powf(0.5)*a1*a2*a5)/((a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[5]=((a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*a5-(a0*a0+a1*a1+a2*a2).powf(0.5)*a0*a2*a3-(a0*a0+a1*a1+a2*a2).powf(0.5)*a1*a2*a4-(a0*a0+a1*a1+a2*a2).powf(0.5)*a2*a2*a5)/((a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5)*(a0*a0+a1*a1+a2*a2).powf(0.5));
          return res;
    }
}

impl trivector_t {
    pub fn normalized(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 12 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=(a0)/((a3*a3).powf(0.5));
          res.d[1]=(a1)/((a3*a3).powf(0.5));
          res.d[2]=(a2)/((a3*a3).powf(0.5));
          res.d[3]=(a3)/((a3*a3).powf(0.5));
          return res;
    }
}

impl quadvector_t {
    pub fn normalized(self) -> quadvector_t {
        let mut res = quadvector_t::new(0.0);
          // a0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 2 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=(a0)/((0.0_f32).powf(0.5));
          return res;
    }
}

impl horizon_t {
    pub fn normalized(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 2 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=(1.0)/((0.0_f32).powf(0.5));
          return res;
    }
}

impl origin_t {
    pub fn normalized(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 2 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=(1.0)/((1.0_f32).powf(0.5));
          return res;
    }
}

impl point_t {
    pub fn normalized(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 8 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(a0)/((1.0_f32).powf(0.5));
          res.d[1]=(a1)/((1.0_f32).powf(0.5));
          res.d[2]=(a2)/((1.0_f32).powf(0.5));
          res.d[3]=(1.0)/((1.0_f32).powf(0.5));
          return res;
    }
}

impl direction_t {
    pub fn normalized(self) -> direction_t {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 6 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(a0)/((0.0_f32).powf(0.5));
          res.d[1]=(a1)/((0.0_f32).powf(0.5));
          res.d[2]=(a2)/((0.0_f32).powf(0.5));
          return res;
    }
}

impl ebivector_t {
    pub fn normalized(self) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 15 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(a0)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[1]=(a1)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[2]=(a2)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          return res;
    }
}

impl ibivector_t {
    pub fn normalized(self) -> ibivector_t {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 6 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(a0)/((0.0_f32).powf(0.5));
          res.d[1]=(a1)/((0.0_f32).powf(0.5));
          res.d[2]=(a2)/((0.0_f32).powf(0.5));
          return res;
    }
}

impl evector_t {
    pub fn normalized(self) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 15 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(a0)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[1]=(a1)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[2]=(a2)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          return res;
    }
}

impl dpoint_t {
    pub fn normalized(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 20 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(a0)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[1]=(a1)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[2]=(a2)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          res.d[3]=(1.0)/((a0*a0+a1*a1+a2*a2).powf(0.5));
          return res;
    }
}

impl rotation_t {
    pub fn normalized(self) -> rotation_t {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 24 muls / 12 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=(a0)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[1]=(a1)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[2]=(a2)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[3]=(a3)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          return res;
    }
}

impl translation_t {
    pub fn normalized(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 8 muls / 0 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(1.0)/((1.0_f32).powf(0.5));
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=(a0)/((1.0_f32).powf(0.5));
          res.d[5]=(a1)/((1.0_f32).powf(0.5));
          res.d[6]=(a2)/((1.0_f32).powf(0.5));
          res.d[7]=0.0;
          return res;
    }
}

impl even_t {
    pub fn normalized(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 360 muls / 160 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=(a0)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[1]=(a1)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[2]=(a2)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[3]=(a3)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[4]=((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a4+(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a0*a1*a7-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a1*a1*a4-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a1*a2*a5-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a1*a3*a6)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[5]=((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a5+(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a0*a2*a7-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a1*a2*a4-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a2*a2*a5-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a2*a3*a6)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[6]=((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a6+(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a0*a3*a7-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a1*a3*a4-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a2*a3*a5-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a3*a3*a6)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          res.d[7]=((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a7+(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a0*a1*a4+(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a0*a2*a5+(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a0*a3*a6-(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*a0*a0*a7)/((a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5)*(a0*a0+a1*a1+a2*a2+a3*a3).powf(0.5));
          return res;
    }
}

impl odd_t {
    pub fn normalized(self) -> odd_t {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 360 muls / 160 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=(a0)/((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5));
          res.d[1]=(a1)/((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5));
          res.d[2]=(a2)/((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5));
          res.d[3]=((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a3-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a0*a4*a7-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a1*a5*a7-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a2*a6*a7-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a3*a7*a7)/((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5));
          res.d[4]=((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a4-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a0*a0*a4-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a0*a1*a5-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a0*a2*a6-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a0*a3*a7)/((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5));
          res.d[5]=((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a5-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a0*a1*a4-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a1*a1*a5-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a1*a2*a6-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a1*a3*a7)/((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5));
          res.d[6]=((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a6-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a0*a2*a4-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a1*a2*a5-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a2*a2*a6-(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*a2*a3*a7)/((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5)*(a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5));
          res.d[7]=(a7)/((a0*a0+a1*a1+a2*a2+a7*a7).powf(0.5));
          return res;
    }
}

impl vector_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl bivector_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl trivector_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl quadvector_t {
    pub fn sqrt(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 5 muls / 0 adds
          let a0=self.d[0];
          res.d[0]=(0.0_f32).powf(0.5);
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=(0.5*a0)/((0.0_f32).powf(0.5));
          return res;
    }
}

impl horizon_t {
    pub fn sqrt(self) -> scalar_t {
        
          // 1 e₀
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl origin_t {
    pub fn sqrt(self) -> scalar_t {
        
          // 1 e₁₂₃
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl point_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl direction_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl ebivector_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl ibivector_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl evector_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl dpoint_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl rotation_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r
          // 2 muls / 0 adds
          let a0=self.d[0];
          return (a0).powf(0.5);
        
    }
}

impl translation_t {
    pub fn sqrt(self) -> scalar_t {
        
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r
          // 2 muls / 0 adds
          return (1.0_f32).powf(0.5);
        
    }
}

impl even_t {
    pub fn sqrt(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 5 muls / 0 adds
        let a0=self.d[0];
        let a7=self.d[7];
          res.d[0]=(a0).powf(0.5);
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=0.0;
          res.d[6]=0.0;
          res.d[7]=(0.5*a7)/((a0).powf(0.5));
          return res;
    }
}

impl odd_t {
    pub fn sqrt(self) -> scalar_t {
        
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r
          // 2 muls / 0 adds
          return (0.0_f32).powf(0.5);
        
    }
}

impl vector_t {
    pub fn sw(a: scalar_t, b: vector_t) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          return res;
    }
}

impl bivector_t {
    pub fn sw(a: scalar_t, b: bivector_t) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=b4;
          res.d[5]=b5;
          return res;
    }
}

impl trivector_t {
    pub fn sw(a: scalar_t, b: trivector_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          return res;
    }
}

impl quadvector_t {
    pub fn sw(a: scalar_t, b: quadvector_t) -> quadvector_t {
        let mut res = quadvector_t::new(0.0);
          // a
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 0 muls / 0 adds
          let b0=b.d[0];
          res.d[0]=b0;
          return res;
    }
}

impl horizon_t {
    pub fn sw(a: scalar_t, b: horizon_t) -> horizon_t {
        let mut res = horizon_t::new();
            return res;
        
    }
}

impl origin_t {
    pub fn sw(a: scalar_t, b: origin_t) -> origin_t {
        let mut res = origin_t::new();
            return res;
        
    }
}

impl point_t {
    pub fn sw(a: scalar_t, b: point_t) -> point_t {
        let mut res = point_t::new(0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

impl direction_t {
    pub fn sw(a: scalar_t, b: direction_t) -> direction_t {
        let mut res = direction_t::new(0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

impl ebivector_t {
    pub fn sw(a: scalar_t, b: ebivector_t) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

impl ibivector_t {
    pub fn sw(a: scalar_t, b: ibivector_t) -> ibivector_t {
        let mut res = ibivector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

impl evector_t {
    pub fn sw(a: scalar_t, b: evector_t) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

impl dpoint_t {
    pub fn sw(a: scalar_t, b: dpoint_t) -> dpoint_t {
        let mut res = dpoint_t::new(0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

impl rotation_t {
    pub fn sw(a: scalar_t, b: rotation_t) -> rotation_t {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          return res;
    }
}

impl translation_t {
    pub fn sw(a: scalar_t, b: translation_t) -> translation_t {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // a
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          return res;
    }
}

impl even_t {
    pub fn sw(a: scalar_t, b: even_t) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
        let b6=b.d[6];
        let b7=b.d[7];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=b4;
          res.d[5]=b5;
          res.d[6]=b6;
          res.d[7]=b7;
          return res;
    }
}

impl odd_t {
    pub fn sw(a: scalar_t, b: odd_t) -> odd_t {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 0 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
        let b6=b.d[6];
        let b7=b.d[7];
          res.d[0]=b0;
          res.d[1]=b1;
          res.d[2]=b2;
          res.d[3]=b3;
          res.d[4]=b4;
          res.d[5]=b5;
          res.d[6]=b6;
          res.d[7]=b7;
          return res;
    }
}

impl vector_t {
    pub fn cprj(a: scalar_t, b: vector_t) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 5 muls / 1 adds
        let b2=b.d[2];
        let b3=b.d[3];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=5.0*a*a*b2-a*a*b3;
          return res;
    }
}

impl bivector_t {
    pub fn cprj(a: scalar_t, b: bivector_t) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 13 muls / 4 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b3=b.d[3];
        let b4=b.d[4];
        let b5=b.d[5];
          res.d[0]=-5.0*a*a*b0-a*a*b4;
          res.d[1]=a*a*b3-5.0*a*a*b1;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=-5.0*a*a*b5;
          return res;
    }
}

impl trivector_t {
    pub fn cprj(a: scalar_t, b: trivector_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 11 muls / 1 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
        let b3=b.d[3];
          res.d[0]=5.0*a*a*b0;
          res.d[1]=5.0*a*a*b1;
          res.d[2]=0.0;
          res.d[3]=a*a*b2+5.0*a*a*b3;
          return res;
    }
}

impl quadvector_t {
    pub fn cprj(a: scalar_t, b: quadvector_t) -> quadvector_t {
        let mut res = quadvector_t::new(0.0);
          // a
          // b0 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 1 adds
          let b0=b.d[0];
          res.d[0]=-5.0*a*a*b0;
          return res;
    }
}

impl horizon_t {
    pub fn cprj(a: scalar_t, b: horizon_t) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a
          // 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 1 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=-a*a;
          return res;
    }
}

impl origin_t {
    pub fn cprj(a: scalar_t, b: origin_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 2 muls / 0 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=5.0*a*a;
          return res;
    }
}

impl point_t {
    pub fn cprj(a: scalar_t, b: point_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 10 muls / 1 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=5.0*a*a*b0;
          res.d[1]=5.0*a*a*b1;
          res.d[2]=0.0;
          res.d[3]=5.0*a*a+a*a*b2;
          return res;
    }
}

impl direction_t {
    pub fn cprj(a: scalar_t, b: direction_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 8 muls / 0 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=5.0*a*a*b0;
          res.d[1]=5.0*a*a*b1;
          res.d[2]=0.0;
          res.d[3]=a*a*b2;
          return res;
    }
}

impl ebivector_t {
    pub fn cprj(a: scalar_t, b: ebivector_t) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₂₃ + b1 e₃₁ + b2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 6 muls / 2 adds
        let b0=b.d[0];
        let b1=b.d[1];
          res.d[0]=-5.0*a*a*b0;
          res.d[1]=-5.0*a*a*b1;
          res.d[2]=0.0;
          return res;
    }
}

impl ibivector_t {
    pub fn cprj(a: scalar_t, b: ibivector_t) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 7 muls / 2 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=-a*a*b1;
          res.d[1]=a*a*b0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=-5.0*a*a*b2;
          return res;
    }
}

impl evector_t {
    pub fn cprj(a: scalar_t, b: evector_t) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 3 muls / 0 adds
          let b2=b.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=5.0*a*a*b2;
          return res;
    }
}

impl dpoint_t {
    pub fn cprj(a: scalar_t, b: dpoint_t) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 4 muls / 1 adds
          let b2=b.d[2];
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=5.0*a*a*b2-a*a;
          return res;
    }
}

impl rotation_t {
    pub fn cprj(a: scalar_t, b: rotation_t) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 6 muls / 2 adds
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=-5.0*a*a*b1;
          res.d[1]=-5.0*a*a*b2;
          res.d[2]=0.0;
          return res;
    }
}

impl translation_t {
    pub fn cprj(a: scalar_t, b: translation_t) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a
          // 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 7 muls / 2 adds
        let b0=b.d[0];
        let b1=b.d[1];
        let b2=b.d[2];
          res.d[0]=-a*a*b1;
          res.d[1]=a*a*b0;
          res.d[2]=0.0;
          res.d[3]=0.0;
          res.d[4]=0.0;
          res.d[5]=-5.0*a*a*b2;
          return res;
    }
}

impl even_t {
    pub fn cprj(a: scalar_t, b: even_t) -> quadvector_t {
        let mut res = quadvector_t::new(0.0);
          // a
          // b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
          // -> r0 e₀₁₂₃
          // 3 muls / 1 adds
          let b7=b.d[7];
          res.d[0]=-5.0*a*a*b7;
          return res;
    }
}

impl odd_t {
    pub fn cprj(a: scalar_t, b: odd_t) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a
          // b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 11 muls / 1 adds
        let b4=b.d[4];
        let b5=b.d[5];
        let b6=b.d[6];
        let b7=b.d[7];
          res.d[0]=5.0*a*a*b4;
          res.d[1]=5.0*a*a*b5;
          res.d[2]=0.0;
          res.d[3]=a*a*b6+5.0*a*a*b7;
          return res;
    }
}

impl vector_t {
    pub fn inverse(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=(a0)/(a0*a0+a1*a1+a2*a2);
          res.d[1]=(a1)/(a0*a0+a1*a1+a2*a2);
          res.d[2]=(a2)/(a0*a0+a1*a1+a2*a2);
          res.d[3]=(a3)/(a0*a0+a1*a1+a2*a2);
          return res;
    }
}

impl bivector_t {
    pub fn inverse(self) -> bivector_t {
        let mut res = bivector_t::new(0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
          // 180 muls / 51 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
          res.d[0]=(-a0*a0*a0-a0*a1*a1-a0*a2*a2)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+a1*a1*a1*a1+2.0*a1*a1*a2*a2+a2*a2*a2*a2);
          res.d[1]=(-a0*a0*a1-a1*a1*a1-a1*a2*a2)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+a1*a1*a1*a1+2.0*a1*a1*a2*a2+a2*a2*a2*a2);
          res.d[2]=(-a0*a0*a2-a1*a1*a2-a2*a2*a2)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+a1*a1*a1*a1+2.0*a1*a1*a2*a2+a2*a2*a2*a2);
          res.d[3]=(a0*a0*a3+2.0*a0*a1*a4+2.0*a0*a2*a5-a1*a1*a3-a2*a2*a3)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+a1*a1*a1*a1+2.0*a1*a1*a2*a2+a2*a2*a2*a2);
          res.d[4]=(2.0*a0*a1*a3+a1*a1*a4+2.0*a1*a2*a5-a0*a0*a4-a2*a2*a4)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+a1*a1*a1*a1+2.0*a1*a1*a2*a2+a2*a2*a2*a2);
          res.d[5]=(2.0*a0*a2*a3+2.0*a1*a2*a4+a2*a2*a5-a0*a0*a5-a1*a1*a5)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+a1*a1*a1*a1+2.0*a1*a1*a2*a2+a2*a2*a2*a2);
          return res;
    }
}

impl trivector_t {
    pub fn inverse(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 3 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=(-a0)/(a3*a3);
          res.d[1]=(-a1)/(a3*a3);
          res.d[2]=(-a2)/(a3*a3);
          res.d[3]=(-1.0)/(a3);
          return res;
    }
}

impl quadvector_t {
    pub fn inverse(self) -> scalar_t {
        
          // a0 e₀₁₂₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl horizon_t {
    pub fn inverse(self) -> scalar_t {
        
          // 1 e₀
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl origin_t {
    pub fn inverse(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 1 adds
          res.d[0]=0.0;
          res.d[1]=0.0;
          res.d[2]=0.0;
          res.d[3]=-1.0;
          return res;
    }
}

impl point_t {
    pub fn inverse(self) -> trivector_t {
        let mut res = trivector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
          // -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
          // 0 muls / 4 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          res.d[3]=-1.0;
          return res;
    }
}

impl direction_t {
    pub fn inverse(self) -> scalar_t {
        
          // a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl ebivector_t {
    pub fn inverse(self) -> ebivector_t {
        let mut res = ebivector_t::new(0.0,0.0,0.0);
          // a0 e₂₃ + a1 e₃₁ + a2 e₁₂
          // -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
          // 9 muls / 9 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(-a0)/(a0*a0+a1*a1+a2*a2);
          res.d[1]=(-a1)/(a0*a0+a1*a1+a2*a2);
          res.d[2]=(-a2)/(a0*a0+a1*a1+a2*a2);
          return res;
    }
}

impl ibivector_t {
    pub fn inverse(self) -> scalar_t {
        
          // a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> r
          // 0 muls / 0 adds
          return 0.0;
        
    }
}

impl evector_t {
    pub fn inverse(self) -> evector_t {
        let mut res = evector_t::new(0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃
          // -> r0 e₁ + r1 e₂ + r2 e₃
          // 9 muls / 6 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(a0)/(a0*a0+a1*a1+a2*a2);
          res.d[1]=(a1)/(a0*a0+a1*a1+a2*a2);
          res.d[2]=(a2)/(a0*a0+a1*a1+a2*a2);
          return res;
    }
}

impl dpoint_t {
    pub fn inverse(self) -> vector_t {
        let mut res = vector_t::new(0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
          // 12 muls / 8 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=(a0)/(a0*a0+a1*a1+a2*a2);
          res.d[1]=(a1)/(a0*a0+a1*a1+a2*a2);
          res.d[2]=(a2)/(a0*a0+a1*a1+a2*a2);
          res.d[3]=(1.0)/(a0*a0+a1*a1+a2*a2);
          return res;
    }
}

impl rotation_t {
    pub fn inverse(self) -> rotation_t {
        let mut res = rotation_t::new(0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
          // 16 muls / 15 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
          res.d[0]=(a0)/(a0*a0+a1*a1+a2*a2+a3*a3);
          res.d[1]=(-a1)/(a0*a0+a1*a1+a2*a2+a3*a3);
          res.d[2]=(-a2)/(a0*a0+a1*a1+a2*a2+a3*a3);
          res.d[3]=(-a3)/(a0*a0+a1*a1+a2*a2+a3*a3);
          return res;
    }
}

impl translation_t {
    pub fn inverse(self) -> translation_t {
        let mut res = translation_t::new(0.0,0.0,0.0);
          // 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
          // -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
          // 0 muls / 3 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
          res.d[0]=-a0;
          res.d[1]=-a1;
          res.d[2]=-a2;
          return res;
    }
}

impl even_t {
    pub fn inverse(self) -> even_t {
        let mut res = even_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
          // -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
          // 388 muls / 111 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=(a0*a0*a0+a0*a1*a1+a0*a2*a2+a0*a3*a3)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a3*a3+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a3*a3+a2*a2*a2*a2+2.0*a2*a2*a3*a3+a3*a3*a3*a3);
          res.d[1]=(-a0*a0*a1-a1*a1*a1-a1*a2*a2-a1*a3*a3)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a3*a3+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a3*a3+a2*a2*a2*a2+2.0*a2*a2*a3*a3+a3*a3*a3*a3);
          res.d[2]=(-a0*a0*a2-a1*a1*a2-a2*a2*a2-a2*a3*a3)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a3*a3+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a3*a3+a2*a2*a2*a2+2.0*a2*a2*a3*a3+a3*a3*a3*a3);
          res.d[3]=(-a0*a0*a3-a1*a1*a3-a2*a2*a3-a3*a3*a3)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a3*a3+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a3*a3+a2*a2*a2*a2+2.0*a2*a2*a3*a3+a3*a3*a3*a3);
          res.d[4]=(a1*a1*a4+2.0*a1*a2*a5+2.0*a1*a3*a6-a0*a0*a4-2.0*a0*a1*a7-a2*a2*a4-a3*a3*a4)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a3*a3+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a3*a3+a2*a2*a2*a2+2.0*a2*a2*a3*a3+a3*a3*a3*a3);
          res.d[5]=(2.0*a1*a2*a4+a2*a2*a5+2.0*a2*a3*a6-a0*a0*a5-2.0*a0*a2*a7-a1*a1*a5-a3*a3*a5)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a3*a3+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a3*a3+a2*a2*a2*a2+2.0*a2*a2*a3*a3+a3*a3*a3*a3);
          res.d[6]=(2.0*a1*a3*a4+2.0*a2*a3*a5+a3*a3*a6-a0*a0*a6-2.0*a0*a3*a7-a1*a1*a6-a2*a2*a6)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a3*a3+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a3*a3+a2*a2*a2*a2+2.0*a2*a2*a3*a3+a3*a3*a3*a3);
          res.d[7]=(2.0*a0*a1*a4+2.0*a0*a2*a5+2.0*a0*a3*a6+a1*a1*a7+a2*a2*a7+a3*a3*a7-a0*a0*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a3*a3+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a3*a3+a2*a2*a2*a2+2.0*a2*a2*a3*a3+a3*a3*a3*a3);
          return res;
    }
}

impl odd_t {
    pub fn inverse(self) -> odd_t {
        let mut res = odd_t::new(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
          // a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
          // -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
          // 388 muls / 109 adds
        let a0=self.d[0];
        let a1=self.d[1];
        let a2=self.d[2];
        let a3=self.d[3];
        let a4=self.d[4];
        let a5=self.d[5];
        let a6=self.d[6];
        let a7=self.d[7];
          res.d[0]=(a0*a0*a0+a0*a1*a1+a0*a2*a2+a0*a7*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a7*a7+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a7*a7+a2*a2*a2*a2+2.0*a2*a2*a7*a7+a7*a7*a7*a7);
          res.d[1]=(a0*a0*a1+a1*a1*a1+a1*a2*a2+a1*a7*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a7*a7+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a7*a7+a2*a2*a2*a2+2.0*a2*a2*a7*a7+a7*a7*a7*a7);
          res.d[2]=(a0*a0*a2+a1*a1*a2+a2*a2*a2+a2*a7*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a7*a7+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a7*a7+a2*a2*a2*a2+2.0*a2*a2*a7*a7+a7*a7*a7*a7);
          res.d[3]=(a0*a0*a3+a1*a1*a3+a2*a2*a3-2.0*a0*a4*a7-2.0*a1*a5*a7-2.0*a2*a6*a7-a3*a7*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a7*a7+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a7*a7+a2*a2*a2*a2+2.0*a2*a2*a7*a7+a7*a7*a7*a7);
          res.d[4]=(a0*a0*a4+2.0*a0*a1*a5+2.0*a0*a2*a6+2.0*a0*a3*a7-a1*a1*a4-a2*a2*a4-a4*a7*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a7*a7+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a7*a7+a2*a2*a2*a2+2.0*a2*a2*a7*a7+a7*a7*a7*a7);
          res.d[5]=(2.0*a0*a1*a4+a1*a1*a5+2.0*a1*a2*a6+2.0*a1*a3*a7-a0*a0*a5-a2*a2*a5-a5*a7*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a7*a7+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a7*a7+a2*a2*a2*a2+2.0*a2*a2*a7*a7+a7*a7*a7*a7);
          res.d[6]=(2.0*a0*a2*a4+2.0*a1*a2*a5+a2*a2*a6+2.0*a2*a3*a7-a0*a0*a6-a1*a1*a6-a6*a7*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a7*a7+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a7*a7+a2*a2*a2*a2+2.0*a2*a2*a7*a7+a7*a7*a7*a7);
          res.d[7]=(-a0*a0*a7-a1*a1*a7-a2*a2*a7-a7*a7*a7)/(a0*a0*a0*a0+2.0*a0*a0*a1*a1+2.0*a0*a0*a2*a2+2.0*a0*a0*a7*a7+a1*a1*a1*a1+2.0*a1*a1*a2*a2+2.0*a1*a1*a7*a7+a2*a2*a2*a2+2.0*a2*a2*a7*a7+a7*a7*a7*a7);
          return res;
    }
}

}